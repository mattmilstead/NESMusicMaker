<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NES Music Maker</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=VT323&family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-dark: #0a0e1a;
            --bg-mid: #161d2f;
            --bg-light: #1e2840;
            --accent-1: #00ff9f;
            --accent-2: #ff006e;
            --accent-3: #8338ec;
            --accent-4: #ffbe0b;
            --text-primary: #e0e7ff;
            --text-secondary: #94a3b8;
            --grid-line: rgba(0, 255, 159, 0.1);
            --glow: 0 0 20px rgba(0, 255, 159, 0.3);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Orbitron', sans-serif;
            background: var(--bg-dark);
            color: var(--text-primary);
            overflow-x: hidden;
            min-height: 100vh;
        }

        /* Animated grid background */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: 
                linear-gradient(var(--grid-line) 1px, transparent 1px),
                linear-gradient(90deg, var(--grid-line) 1px, transparent 1px);
            background-size: 50px 50px;
            animation: gridMove 20s linear infinite;
            pointer-events: none;
            z-index: 0;
        }

        @keyframes gridMove {
            0% { transform: translateY(0); }
            100% { transform: translateY(50px); }
        }

        .container {
            position: relative;
            z-index: 1;
            max-width: 1800px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            text-align: center;
            padding: 40px 20px;
            margin-bottom: 40px;
            background: linear-gradient(135deg, var(--bg-mid) 0%, var(--bg-light) 100%);
            border: 2px solid var(--accent-1);
            border-radius: 8px;
            box-shadow: var(--glow), inset 0 1px 0 rgba(255, 255, 255, 0.1);
            position: relative;
            overflow: hidden;
        }

        header::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(0, 255, 159, 0.1) 0%, transparent 50%);
            animation: pulse 4s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 0.5; }
            50% { transform: scale(1.1); opacity: 0.8; }
        }

        h1 {
            font-family: 'Press Start 2P', cursive;
            font-size: 2.5rem;
            color: var(--accent-1);
            text-shadow: 0 0 10px var(--accent-1), 0 4px 0 #004d3d;
            letter-spacing: 4px;
            margin-bottom: 10px;
            position: relative;
            z-index: 1;
            animation: glitch 3s infinite;
        }

        @keyframes glitch {
            0%, 90%, 100% { transform: translateX(0); }
            92% { transform: translateX(-2px); }
            94% { transform: translateX(2px); }
            96% { transform: translateX(-2px); }
        }

        .subtitle {
            font-family: 'VT323', monospace;
            font-size: 1.2rem;
            color: var(--accent-4);
            letter-spacing: 2px;
            position: relative;
            z-index: 1;
        }

        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .control-group {
            background: var(--bg-mid);
            padding: 20px;
            border-radius: 8px;
            border: 1px solid var(--accent-3);
            box-shadow: 0 4px 20px rgba(131, 56, 236, 0.2);
            transition: all 0.3s ease;
        }

        .control-group:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 30px rgba(131, 56, 236, 0.4);
            border-color: var(--accent-1);
        }

        .control-group label {
            display: block;
            font-size: 0.85rem;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 10px;
            color: var(--accent-4);
        }

        .file-input-wrapper {
            position: relative;
            overflow: hidden;
            display: inline-block;
            width: 100%;
        }

        input[type="file"] {
            position: absolute;
            left: -9999px;
        }

        .file-input-label {
            display: block;
            padding: 12px 20px;
            background: linear-gradient(135deg, var(--accent-2) 0%, var(--accent-3) 100%);
            color: white;
            text-align: center;
            cursor: pointer;
            border-radius: 4px;
            font-weight: 700;
            transition: all 0.3s ease;
            text-transform: uppercase;
            font-size: 0.9rem;
            letter-spacing: 1px;
        }

        .file-input-label:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 20px rgba(255, 0, 110, 0.5);
        }

        select, button {
            width: 100%;
            padding: 12px;
            background: var(--bg-light);
            color: var(--text-primary);
            border: 2px solid var(--accent-1);
            border-radius: 4px;
            font-family: 'Orbitron', sans-serif;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        input[type="number"] {
            width: 100%;
            padding: 12px;
            background: var(--bg-light);
            color: var(--text-primary);
            border: 2px solid var(--accent-1);
            border-radius: 4px;
            font-family: 'Orbitron', sans-serif;
            font-size: 0.9rem;
        }

        button {
            background: linear-gradient(135deg, var(--accent-1) 0%, #00cc7f 100%);
            color: var(--bg-dark);
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 4px 20px rgba(0, 255, 159, 0.5);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .stems-list {
            margin-bottom: 30px;
        }

        .stem-item {
            background: var(--bg-mid);
            padding: 15px;
            margin-bottom: 10px;
            border-radius: 8px;
            border-left: 4px solid var(--accent-1);
            display: flex;
            justify-content: space-between;
            align-items: center;
            animation: slideIn 0.5s ease;
        }

        @keyframes slideIn {
            from { transform: translateX(-20px); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        .stem-info {
            flex: 1;
        }

        .stem-name {
            font-weight: 700;
            color: var(--accent-1);
            margin-bottom: 5px;
        }

        .stem-details {
            font-size: 0.8rem;
            color: var(--text-secondary);
        }

        .stem-actions {
            display: flex;
            gap: 10px;
        }

        .stem-actions button {
            padding: 8px 15px;
            font-size: 0.8rem;
        }

        /* Timeline styles */
        .timeline {
            background: var(--bg-mid);
            border: 2px solid var(--accent-3);
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 30px;
            position: relative;
            box-shadow: 0 4px 30px rgba(131, 56, 236, 0.3);
        }

        .timeline-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid var(--accent-1);
        }

        .timeline-title {
            font-family: 'Press Start 2P', cursive;
            font-size: 1rem;
            color: var(--accent-4);
            letter-spacing: 2px;
        }

        .playback-controls {
            display: flex;
            gap: 10px;
        }

        .playback-controls button {
            width: 50px;
            height: 50px;
            padding: 0;
            font-size: 1.2rem;
            border-radius: 50%;
        }

        .track-container {
            position: relative;
            overflow-x: auto;
            overflow-y: visible;
        }

        .track {
            margin-bottom: 15px;
            border: 1px solid var(--accent-3);
            border-radius: 4px;
            overflow: hidden;
            background: var(--bg-light);
            transition: all 0.3s ease;
        }

        .track.expanded {
            margin-bottom: 30px;
        }

        .track.focused {
            border: 2px solid var(--accent-1);
            box-shadow: 0 0 10px rgba(0, 255, 159, 0.3);
        }

        .track-header {
            background: var(--bg-dark);
            padding: 10px 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 2px solid var(--accent-3);
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .track-header:hover {
            background: var(--bg-mid);
        }

        .track-label {
            font-weight: 700;
            font-size: 0.9rem;
            display: flex;
            align-items: center;
            gap: 10px;
            flex: 1; /* Take full available width */
        }

        .track-expand-indicator {
            color: var(--accent-1);
            font-size: 0.8rem;
            opacity: 0.6;
            transition: opacity 0.2s ease;
        }

        .track-header:hover .track-expand-indicator {
            opacity: 1;
        }

        .channel-badge {
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 0.75rem;
            font-weight: 700;
            letter-spacing: 1px;
        }

        .channel-badge.pulse1 { background: var(--accent-2); color: white; }
        .channel-badge.pulse2 { background: var(--accent-3); color: white; }
        .channel-badge.triangle { background: var(--accent-1); color: var(--bg-dark); }
        .channel-badge.noise { background: var(--accent-4); color: var(--bg-dark); }

        .track-content {
            min-height: 80px;
            position: relative;
            background: var(--bg-light);
            cursor: crosshair;
            transition: min-height 0.3s ease;
            overflow-x: auto;
            overflow-y: hidden;
            user-select: none; /* Prevent text selection */
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }

        .track-content.piano-roll-mode {
            min-height: 400px;
            max-height: 320px; /* 16 rows * 20px per row */
            display: flex;
            cursor: default;
            overflow-y: auto;
            background: none; /* Remove simple view grid background */
        }

        .inline-piano-keys {
            width: 60px;
            min-width: 60px;
            flex-shrink: 0;
            background: var(--bg-dark);
            border-right: 2px solid var(--accent-3);
            overflow-y: auto;
            display: none;
            position: sticky;
            left: 0;
            z-index: 10;
        }

        .track-content.piano-roll-mode .inline-piano-keys {
            display: block;
        }

        .inline-piano-key {
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-bottom: 1px solid var(--accent-3);
            font-size: 0.65rem;
            color: #000;
            background: #fff;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .inline-piano-key.black-key {
            background: #000;
            color: white;
            border-bottom: 1px solid #333;
        }

        .inline-piano-key:hover {
            background: var(--accent-3);
            color: white;
        }

        .inline-piano-grid {
            flex: 1;
            overflow: auto;
            position: relative;
            display: none;
            min-width: fit-content;
        }

        .track-content.piano-roll-mode .inline-piano-grid {
            display: block;
        }

        .inline-piano-grid-row {
            height: 20px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
            position: relative;
            cursor: crosshair;
            background: transparent;
            z-index: 1;
        }
        
        /* Lighter background for white key rows (C, D, E, F, G, A, B) 
           Rows are in REVERSE order (highest to lowest), so we need to match correctly.
           Pattern in each octave (from low to high): C, C#, D, D#, E, F, F#, G, G#, A, A#, B
           White keys are positions: 0, 2, 4, 5, 7, 9, 11 (C, D, E, F, G, A, B)
           Since rows are reversed, counting from bottom...
        */
        .inline-piano-grid-row[data-freq-index="0"],  /* Check data attribute instead */
        .inline-piano-grid-row[data-freq-index="2"],
        .inline-piano-grid-row[data-freq-index="4"],
        .inline-piano-grid-row[data-freq-index="5"],
        .inline-piano-grid-row[data-freq-index="7"],
        .inline-piano-grid-row[data-freq-index="9"],
        .inline-piano-grid-row[data-freq-index="11"],
        .inline-piano-grid-row[data-freq-index="12"],
        .inline-piano-grid-row[data-freq-index="14"],
        .inline-piano-grid-row[data-freq-index="16"],
        .inline-piano-grid-row[data-freq-index="17"],
        .inline-piano-grid-row[data-freq-index="19"],
        .inline-piano-grid-row[data-freq-index="21"],
        .inline-piano-grid-row[data-freq-index="23"],
        .inline-piano-grid-row[data-freq-index="24"],
        .inline-piano-grid-row[data-freq-index="26"],
        .inline-piano-grid-row[data-freq-index="28"],
        .inline-piano-grid-row[data-freq-index="29"],
        .inline-piano-grid-row[data-freq-index="31"],
        .inline-piano-grid-row[data-freq-index="33"],
        .inline-piano-grid-row[data-freq-index="35"],
        .inline-piano-grid-row[data-freq-index="36"],
        .inline-piano-grid-row[data-freq-index="38"],
        .inline-piano-grid-row[data-freq-index="40"],
        .inline-piano-grid-row[data-freq-index="41"],
        .inline-piano-grid-row[data-freq-index="43"],
        .inline-piano-grid-row[data-freq-index="45"],
        .inline-piano-grid-row[data-freq-index="47"],
        .inline-piano-grid-row[data-freq-index="48"],
        .inline-piano-grid-row[data-freq-index="50"],
        .inline-piano-grid-row[data-freq-index="52"],
        .inline-piano-grid-row[data-freq-index="53"],
        .inline-piano-grid-row[data-freq-index="55"],
        .inline-piano-grid-row[data-freq-index="57"],
        .inline-piano-grid-row[data-freq-index="59"] {
            background: rgba(255, 255, 255, 0.025);
        }

        .inline-piano-grid-row:hover {
            background: rgba(0, 255, 159, 0.05);
        }

        .inline-piano-note {
            position: absolute;
            height: 18px;
            top: 1px;
            background: linear-gradient(135deg, var(--accent-1) 0%, #00cc7f 100%);
            border: 2px solid var(--accent-1);
            border-radius: 3px;
            display: flex;
            align-items: center;
            padding: 0 5px;
            font-size: 0.65rem;
            color: var(--bg-dark);
            font-weight: 700;
            transition: all 0.2s ease;
            overflow: visible;
        }

        .inline-piano-note:hover {
            transform: scaleY(1.2);
            box-shadow: 0 2px 10px rgba(0, 255, 159, 0.5);
            z-index: 10;
        }

        .inline-piano-note.selected {
            border-color: var(--accent-2);
            box-shadow: 0 0 15px var(--accent-2);
            z-index: 11;
        }

        .inline-piano-note-resize {
            position: absolute;
            right: -10px;
            top: 0;
            bottom: 0;
            width: 16px;
            background: transparent;
            cursor: ew-resize;
            z-index: 12;
        }

        .inline-piano-note-resize:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        
        .inline-piano-note-resize-left {
            position: absolute;
            left: -10px;
            top: 0;
            bottom: 0;
            width: 16px;
            background: transparent;
            cursor: ew-resize;
            z-index: 12;
        }
        
        .inline-piano-note-resize-left:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .track-content.piano-roll-mode .waveform-placeholder {
            display: none;
        }

        .track-content.piano-roll-mode .track-simple-content {
            display: none;
        }

        .track-simple-content {
            position: relative;
            min-height: 80px;
            padding-left: 0; /* No padding - we handle spacing differently */
        }

        .track-simple-content::before {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            width: 60px;
            background: var(--bg-dark);
            border-right: 2px solid var(--accent-3);
            opacity: 0.3;
            z-index: 1;
        }

        .track-content.piano-roll-mode .track-simple-content::before {
            display: none;
        }

        .track-content:not(.piano-roll-mode) .inline-piano-keys,
        .track-content:not(.piano-roll-mode) .inline-piano-grid {
            display: none !important;
            pointer-events: none !important;
            visibility: hidden !important;
        }

        .waveform-placeholder {
            height: 80px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--text-secondary);
            font-size: 0.8rem;
            font-style: italic;
            position: absolute;
            left: 62px;
            right: 0;
            z-index: 2;
        }

        .note-block {
            position: absolute;
            background: linear-gradient(135deg, var(--accent-1) 0%, #00cc7f 100%);
            border: 2px solid var(--accent-1);
            border-radius: 4px;
            cursor: move;
            transition: all 0.2s ease;
            box-shadow: 0 2px 10px rgba(0, 255, 159, 0.3);
            height: 70px;
            top: 5px;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }

        .note-block:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 20px rgba(0, 255, 159, 0.6);
            z-index: 10;
        }

        .note-block.selected {
            border-color: var(--accent-2);
            box-shadow: 0 0 20px var(--accent-2);
            z-index: 11;
        }

        .note-block .note-label {
            padding: 4px 8px;
            font-size: 0.7rem;
            font-weight: 700;
            color: var(--bg-dark);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .note-block .resize-handle {
            position: absolute;
            right: 0;
            top: 0;
            bottom: 0;
            width: 8px;
            background: rgba(255, 255, 255, 0.3);
            cursor: ew-resize;
        }

        .note-block .resize-handle:hover {
            background: rgba(255, 255, 255, 0.6);
        }

        .playhead {
            position: fixed;
            top: 0;
            bottom: 0;
            width: 2px;
            background: var(--accent-2);
            z-index: 1000;
            pointer-events: none;
            box-shadow: 0 0 10px var(--accent-2);
            display: none;
            left: 0;
        }

        .status-bar {
            background: var(--bg-mid);
            padding: 15px 20px;
            border-radius: 4px;
            border-left: 4px solid var(--accent-1);
            font-family: 'VT323', monospace;
            font-size: 1.1rem;
            color: var(--text-secondary);
        }

        .status-bar .processing {
            color: var(--accent-4);
            animation: blink 1s infinite;
        }

        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0.3; }
        }

        /* New styles for song length control */
        .song-length-display {
            font-family: 'VT323', monospace;
            font-size: 1rem;
            color: var(--accent-1);
            margin-top: 5px;
        }

        /* Selection box for drag-select */
        .selection-box {
            position: fixed;
            border: 2px solid var(--accent-1);
            background: rgba(0, 255, 159, 0.1);
            pointer-events: none;
            z-index: 9999;
            display: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>NES MUSIC MAKER</h1>
        </header>

        <div class="controls" style="display: flex; gap: 10px;">
            <!-- Left Column: File I/O and Song Settings (1/4 width) -->
            <div style="flex: 0 0 25%; display: flex; flex-direction: column; gap: 10px;">
                <!-- File I/O Section -->
                <div style="background: var(--bg-mid); padding: 10px; border-radius: 4px; border: 2px solid var(--accent-1);">
                    <label style="font-size: 0.9rem; font-weight: bold; color: var(--accent-1); margin-bottom: 8px; display: block;">File I/O</label>
                    
                    <button id="newProjectBtn" style="width: 100%; padding: 8px; font-size: 0.8rem; background: var(--bg-dark); border: 1px solid var(--accent-1); border-radius: 4px; cursor: pointer; color: var(--text-primary); margin-bottom: 6px;">
                        üìÑ New Project
                    </button>
                    
                    <div class="file-input-wrapper" style="margin-bottom: 6px;">
                        <input type="file" id="loadProjectBtn" accept=".nes,.json,.txt" multiple style="display: none;">
                        <label for="loadProjectBtn" class="file-input-label" style="width: 100%; padding: 8px; font-size: 0.8rem; background: var(--bg-dark); border: 1px solid var(--accent-1); border-radius: 4px; cursor: pointer; color: var(--text-primary); display: block; text-align: center; box-sizing: border-box;">
                            üìÇ Load Project / FamiTracker
                        </label>
                    </div>
                    
                    <button id="saveProjectBtn" style="width: 100%; padding: 8px; font-size: 0.8rem; background: var(--bg-dark); border: 1px solid var(--accent-1); border-radius: 4px; cursor: pointer; color: var(--text-primary); margin-bottom: 6px;">
                        üíæ Save Project
                    </button>
                    
                    <button id="exportBtn" style="width: 100%; padding: 8px; font-size: 0.8rem; background: linear-gradient(135deg, var(--accent-4) 0%, #d69e00 100%); border: none; border-radius: 4px; cursor: pointer; color: white;">
                        üì§ Export FamiTracker
                    </button>
                </div>

                <!-- Song Settings -->
                <div style="background: var(--bg-mid); padding: 10px; border-radius: 4px; border: 2px solid var(--accent-1); display: flex; flex-direction: column;">
                    <label style="font-size: 0.9rem; font-weight: bold; color: var(--accent-1); margin-bottom: 8px; display: block;">Song Settings</label>
                    
                    <div style="margin-bottom: 10px;">
                        <label style="font-size: 0.75rem; color: var(--text-secondary); display: block; margin-bottom: 3px;">Length (s)</label>
                        <input type="number" id="songLengthInput" value="30" min="5" max="600" step="5" style="width: 100%; padding: 5px; font-size: 0.8rem; background: var(--bg-dark); color: var(--text-primary); border: 1px solid var(--accent-1); border-radius: 3px;">
                    </div>
                    
                    <div style="margin-bottom: 10px;">
                        <label style="font-size: 0.75rem; color: var(--text-secondary); display: block; margin-bottom: 3px;">BPM</label>
                        <div style="display: flex; gap: 4px;">
                            <input type="number" id="bpmInput" value="120" min="60" max="240" step="1" 
                                   style="width: 60%; padding: 5px; background: var(--bg-dark); color: var(--text-primary); border: 1px solid var(--accent-1); border-radius: 3px; font-family: 'Orbitron', sans-serif; font-size: 0.8rem;">
                            <button id="tapTempoBtn" style="width: 40%; padding: 5px; font-size: 0.65rem; background: linear-gradient(135deg, var(--accent-3) 0%, #6b28c7 100%); border: none; border-radius: 3px; cursor: pointer; color: white;">
                                üëÜ TAP
                            </button>
                        </div>
                    </div>
                    
                    <div style="margin-bottom: 10px;">
                        <label style="font-size: 0.75rem; color: var(--text-secondary); display: block; margin-bottom: 3px;">Time Signature</label>
                        <select id="timeSignature" style="width: 100%; padding: 5px; font-size: 0.8rem; background: var(--bg-dark); color: var(--text-primary); border: 1px solid var(--accent-1); border-radius: 3px;">
                            <option value="4">4/4 (Common)</option>
                            <option value="3">3/4 (Waltz)</option>
                        </select>
                    </div>
                    
                    <div style="margin-bottom: 0;">
                        <label style="font-size: 0.75rem; color: var(--text-secondary); display: block; margin-bottom: 3px;">Quantization</label>
                        <select id="noteQuantization" style="width: 100%; padding: 5px; font-size: 0.8rem; background: var(--bg-dark); color: var(--text-primary); border: 1px solid var(--accent-1); border-radius: 3px;">
                            <option value="none">None (Free)</option>
                            <option value="eighth" selected>8th Notes</option>
                            <option value="sixteenth">16th Notes</option>
                            <option value="thirtysecond">32nd Notes</option>
                        </select>
                    </div>
                </div>
                
                <!-- Keyboard Shortcuts Button -->
                <button id="helpBtn" style="width: 100%; padding: 8px; font-size: 0.75rem; background: linear-gradient(135deg, var(--accent-3) 0%, #6b28c7 100%); border: none; border-radius: 4px; cursor: pointer; color: white; margin-top: 10px;">
                    ‚å®Ô∏è KEYBOARD SHORTCUTS
                </button>
            </div>

            <!-- Right Column: Instruments (3/4 width) -->
            <div style="flex: 1; display: flex; flex-direction: column;">
                <!-- Top-level header row -->
                <div style="display: flex; gap: 10px; margin-bottom: 8px;">
                    <div style="flex: 0 0 25%;">
                        <label style="display: block; font-weight: bold; color: var(--accent-1);">Instruments</label>
                    </div>
                    <div style="flex: 1; display: flex; justify-content: space-between; align-items: center;">
                        <label style="font-weight: bold; color: var(--accent-1);">Envelopes</label>
                        <div style="display: flex; gap: 6px;">
                            <button id="previewInstrumentBtn" style="padding: 6px 12px; font-size: 0.75rem; background: var(--accent-1); border: none; border-radius: 3px; cursor: pointer; color: white; display: flex; align-items: center; gap: 6px;">
                                <span>‚ñ∂</span><span>Preview</span>
                            </button>
                            <button id="stopPreviewBtn" style="padding: 6px 12px; font-size: 0.75rem; background: var(--bg-dark); border: 1px solid var(--accent-1); border-radius: 3px; cursor: pointer; color: var(--text-primary); display: flex; align-items: center; gap: 6px;">
                                <span>‚èπ</span><span>Stop</span>
                            </button>
                        </div>
                    </div>
                </div>
                
                <div style="display: flex; gap: 10px; flex: 1; min-height: 0;">
                    <!-- Instrument List (1/4) -->
                    <div style="flex: 0 0 25%; display: flex; flex-direction: column; background: var(--bg-light); border: 2px solid var(--accent-1); border-radius: 4px; padding: 8px;">
                        <div id="instrumentsList" style="flex: 1; overflow-y: auto; margin-bottom: 8px;">
                            <!-- Instruments will be listed here -->
                        </div>
                        <div style="display: flex; flex-direction: column; gap: 6px;">
                            <button id="addInstrumentBtn" style="padding: 6px; font-size: 0.8rem; background: linear-gradient(135deg, var(--accent-1) 0%, #00cc7f 100%); border: none; border-radius: 3px; cursor: pointer; color: white;">
                                ‚ûï Add
                            </button>
                            <button id="importFTIBtn" style="padding: 6px; font-size: 0.8rem; background: linear-gradient(135deg, var(--accent-3) 0%, #6b28c7 100%); border: none; border-radius: 3px; cursor: pointer; color: white;">
                                üìÅ Import
                            </button>
                        </div>
                        <input type="file" id="ftiFileInput" accept=".fti" multiple style="display: none;">
                    </div>
                    
                    <!-- Instrument Editor (3/4) -->
                    <div style="flex: 1; background: var(--bg-mid); border: 2px solid var(--accent-1); border-radius: 4px; padding: 10px; display: flex; flex-direction: column; overflow-y: auto;">
                        <div id="instrumentEditorContent" style="display: flex; flex-direction: column; flex: 1;">
                            <div style="text-align: center; color: var(--text-secondary); padding: 20px;">
                                Select an instrument to edit
                            </div>
                        </div>
                    </div>
                </div>
                
            </div>
        </div>

        <div class="stems-list" id="stemsList"></div>

        <div class="timeline">
            <div class="timeline-header">
                <div class="timeline-title">
                    TIMELINE
                    <div id="zoomDisplay" style="font-size: 0.7em; color: var(--accent-1); margin-top: 2px;">Zoom: 100%</div>
                </div>
                
                <!-- MIDI Controls (center) -->
                <div style="display: flex; align-items: center; gap: 12px;">
                    <div id="midiStatus" style="font-size: 0.75rem; color: var(--text-secondary);">
                        üéπ MIDI: Checking...
                    </div>
                    <label style="font-size: 0.75rem; color: var(--text-secondary); display: flex; align-items: center; gap: 4px; cursor: pointer;" title="Quantize MIDI to 8th notes">
                        <input type="checkbox" id="midiQuantize" checked tabindex="-1">
                        Quantize
                    </label>
                    <label style="font-size: 0.75rem; color: var(--text-secondary); display: flex; align-items: center; gap: 4px; cursor: pointer;" title="Click track during playback">
                        <input type="checkbox" id="clickTrack" checked tabindex="-1">
                        Click
                    </label>
                </div>
                
                <!-- Playback controls (right) -->
                <div class="playback-controls">
                    <button id="playBtn" title="Play">‚ñ∂</button>
                    <button id="stopBtn" title="Stop">‚èπ</button>
                    <button id="loopBtn" title="Toggle Loop" style="margin-left: 10px; background: var(--bg-mid); color: var(--text-secondary);">üîÅ</button>
                </div>
            </div>
            
            <!-- Visual Timeline Scrubber (below header) -->
            <div id="timelineScrubber" style="position: relative; height: 30px; background: #0a8a5f; border-radius: 4px; margin-bottom: 20px; cursor: crosshair; overflow: visible; user-select: none;">
                <!-- Notes visualization canvas -->
                <canvas id="timelineNotesCanvas" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; border-radius: 4px; z-index: 1;"></canvas>
                <!-- Loop region highlight -->
                <div id="loopRegion" style="position: absolute; top: 0; bottom: 0; background: rgba(255, 107, 157, 0.5); border-left: 2px solid #ff6b9d; border-right: 2px solid #ff6b9d; pointer-events: none; z-index: 5;"></div>
                <!-- Playhead indicator -->
                <div id="timelinePlayhead" style="position: absolute; top: -5px; bottom: -5px; width: 3px; background: #ff6b9d; box-shadow: 0 0 8px #ff6b9d; pointer-events: none; z-index: 10;"></div>
            </div>

            <div class="track-container">
                <div class="track pulse1">
                    <div class="track-header" data-channel="pulse1">
                        <div class="track-label">
                            <span class="channel-badge pulse1">PULSE 1</span>
                            <button class="mute-btn" data-channel="pulse1" style="margin-left: 8px; width: 24px; height: 24px; padding: 0; font-size: 0.7rem; font-weight: bold; background: var(--bg-mid); color: var(--text-secondary); border: 1px solid var(--accent-3); border-radius: 50%; cursor: pointer; display: inline-flex; align-items: center; justify-content: center;">M</button>
                            <button class="solo-btn" data-channel="pulse1" style="margin-left: 4px; width: 24px; height: 24px; padding: 0; font-size: 0.7rem; font-weight: bold; background: var(--bg-mid); color: var(--text-secondary); border: 1px solid var(--accent-1); border-radius: 50%; cursor: pointer; display: inline-flex; align-items: center; justify-content: center;">S</button>
                            <button class="record-arm-btn" data-channel="pulse1" style="margin-left: 4px; width: 24px; height: 24px; padding: 0; font-size: 0.7rem; font-weight: bold; background: var(--bg-mid); color: var(--text-secondary); border: 1px solid var(--accent-2); border-radius: 50%; cursor: pointer; display: inline-flex; align-items: center; justify-content: center;">R</button>
                            <div class="instrument-reference-bar" id="pulse1InstrumentBar" style="display: none; margin-left: 12px; overflow-x: auto; white-space: nowrap; pointer-events: none;"></div>
                            <span class="track-expand-indicator" style="margin-left: auto;">‚ñº Click to expand piano roll</span>
                        </div>
                    </div>
                    <div class="track-content" id="pulse1Track">
                        <div class="inline-piano-keys" id="pulse1PianoKeys"></div>
                        <div class="inline-piano-grid" id="pulse1PianoGrid"></div>
                        <div class="track-simple-content">
                            <div class="waveform-placeholder">Click to add notes or expand for piano roll</div>
                        </div>
                    </div>
                </div>

                <div class="track pulse2">
                    <div class="track-header" data-channel="pulse2">
                        <div class="track-label">
                            <span class="channel-badge pulse2">PULSE 2</span>
                            <button class="mute-btn" data-channel="pulse2" style="margin-left: 8px; width: 24px; height: 24px; padding: 0; font-size: 0.7rem; font-weight: bold; background: var(--bg-mid); color: var(--text-secondary); border: 1px solid var(--accent-3); border-radius: 50%; cursor: pointer; display: inline-flex; align-items: center; justify-content: center;">M</button>
                            <button class="solo-btn" data-channel="pulse2" style="margin-left: 4px; width: 24px; height: 24px; padding: 0; font-size: 0.7rem; font-weight: bold; background: var(--bg-mid); color: var(--text-secondary); border: 1px solid var(--accent-1); border-radius: 50%; cursor: pointer; display: inline-flex; align-items: center; justify-content: center;">S</button>
                            <button class="record-arm-btn" data-channel="pulse2" style="margin-left: 4px; width: 24px; height: 24px; padding: 0; font-size: 0.7rem; font-weight: bold; background: var(--bg-mid); color: var(--text-secondary); border: 1px solid var(--accent-2); border-radius: 50%; cursor: pointer; display: inline-flex; align-items: center; justify-content: center;">R</button>
                            <div class="instrument-reference-bar" id="pulse2InstrumentBar" style="display: none; margin-left: 12px; overflow-x: auto; white-space: nowrap; pointer-events: none;"></div>
                            <span class="track-expand-indicator" style="margin-left: auto;">‚ñº Click to expand piano roll</span>
                        </div>
                    </div>
                    <div class="track-content" id="pulse2Track">
                        <div class="inline-piano-keys" id="pulse2PianoKeys"></div>
                        <div class="inline-piano-grid" id="pulse2PianoGrid"></div>
                        <div class="track-simple-content">
                            <div class="waveform-placeholder">Click to add notes or expand for piano roll</div>
                        </div>
                    </div>
                </div>

                <div class="track triangle">
                    <div class="track-header" data-channel="triangle">
                        <div class="track-label">
                            <span class="channel-badge triangle">TRIANGLE</span>
                            <button class="mute-btn" data-channel="triangle" style="margin-left: 8px; width: 24px; height: 24px; padding: 0; font-size: 0.7rem; font-weight: bold; background: var(--bg-mid); color: var(--text-secondary); border: 1px solid var(--accent-3); border-radius: 50%; cursor: pointer; display: inline-flex; align-items: center; justify-content: center;">M</button>
                            <button class="solo-btn" data-channel="triangle" style="margin-left: 4px; width: 24px; height: 24px; padding: 0; font-size: 0.7rem; font-weight: bold; background: var(--bg-mid); color: var(--text-secondary); border: 1px solid var(--accent-1); border-radius: 50%; cursor: pointer; display: inline-flex; align-items: center; justify-content: center;">S</button>
                            <button class="record-arm-btn" data-channel="triangle" style="margin-left: 4px; width: 24px; height: 24px; padding: 0; font-size: 0.7rem; font-weight: bold; background: var(--bg-mid); color: var(--text-secondary); border: 1px solid var(--accent-2); border-radius: 50%; cursor: pointer; display: inline-flex; align-items: center; justify-content: center;">R</button>
                            <div class="instrument-reference-bar" id="triangleInstrumentBar" style="display: none; margin-left: 12px; overflow-x: auto; white-space: nowrap; pointer-events: none;"></div>
                            <span class="track-expand-indicator" style="margin-left: auto;">‚ñº Click to expand piano roll</span>
                        </div>
                    </div>
                    <div class="track-content" id="triangleTrack">
                        <div class="inline-piano-keys" id="trianglePianoKeys"></div>
                        <div class="inline-piano-grid" id="trianglePianoGrid"></div>
                        <div class="track-simple-content">
                            <div class="waveform-placeholder">Click to add notes or expand for piano roll</div>
                        </div>
                    </div>
                </div>

                <div class="track noise">
                    <div class="track-header" data-channel="noise">
                        <div class="track-label">
                            <span class="channel-badge noise">NOISE</span>
                            <button class="mute-btn" data-channel="noise" style="margin-left: 8px; width: 24px; height: 24px; padding: 0; font-size: 0.7rem; font-weight: bold; background: var(--bg-mid); color: var(--text-secondary); border: 1px solid var(--accent-3); border-radius: 50%; cursor: pointer; display: inline-flex; align-items: center; justify-content: center;">M</button>
                            <button class="solo-btn" data-channel="noise" style="margin-left: 4px; width: 24px; height: 24px; padding: 0; font-size: 0.7rem; font-weight: bold; background: var(--bg-mid); color: var(--text-secondary); border: 1px solid var(--accent-1); border-radius: 50%; cursor: pointer; display: inline-flex; align-items: center; justify-content: center;">S</button>
                            <button class="record-arm-btn" data-channel="noise" style="margin-left: 4px; width: 24px; height: 24px; padding: 0; font-size: 0.7rem; font-weight: bold; background: var(--bg-mid); color: var(--text-secondary); border: 1px solid var(--accent-2); border-radius: 50%; cursor: pointer; display: inline-flex; align-items: center; justify-content: center;">R</button>
                            <div class="instrument-reference-bar" id="noiseInstrumentBar" style="display: none; margin-left: 12px; overflow-x: auto; white-space: nowrap; pointer-events: none;"></div>
                            <span class="track-expand-indicator" style="margin-left: auto;">‚ñº Click to expand piano roll</span>
                        </div>
                    </div>
                    <div class="track-content" id="noiseTrack">
                        <div class="inline-piano-keys" id="noisePianoKeys"></div>
                        <div class="inline-piano-grid" id="noisePianoGrid"></div>
                        <div class="track-simple-content">
                            <div class="waveform-placeholder">Click to add notes or expand for piano roll</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="status-bar" id="statusBar">
            Ready to compose - Click track headers to expand piano roll editor
        </div>
    </div>

    <!-- Playhead -->
    <div class="playhead" id="playhead"></div>

    <!-- Selection box for drag-select -->
    <div class="selection-box" id="selectionBox"></div>

    <script>
        // Audio context for processing
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        let uploadedFiles = [];
        let convertedTracks = {
            pulse1: null,
            pulse2: null,
            triangle: null,
            noise: null
        };

        // Instrument system
        let instruments = [
            { id: 1, name: 'Default', dutyCycle: 2, color: '#00ff9f' } // Mint green, 50% duty cycle
        ];
        let nextInstrumentId = 2; // Start at 2 since Default is 1

        // Parse FTI (FamiTracker Instrument) file
        function parseFTI(arrayBuffer, filename) {
            const view = new DataView(arrayBuffer);
            let offset = 0;
            
            // Read header "FTI2.1" or similar
            const header = String.fromCharCode(...new Uint8Array(arrayBuffer, 0, 6));
            if (!header.startsWith('FTI')) {
                console.error('Not a valid FTI file');
                return null;
            }
            offset = 6;
            
            // Instrument type (1 byte) - 01 = 2A03
            const instType = view.getUint8(offset++);
            
            // Sequence count (4 bytes)
            const seqCount = view.getUint32(offset, true);
            offset += 4;
            
            // Instrument name (null-terminated string)
            let nameBytes = [];
            while (offset < arrayBuffer.byteLength && view.getUint8(offset) !== 0) {
                nameBytes.push(view.getUint8(offset++));
            }
            offset++; // Skip null terminator
            
            const name = String.fromCharCode(...nameBytes) || filename.replace('.fti', '');
            
            // Read sequences (volume, arpeggio, pitch, hi-pitch, duty)
            const sequences = [];
            for (let i = 0; i < seqCount; i++) {
                if (offset >= arrayBuffer.byteLength) break;
                
                const seqEnabled = view.getUint8(offset++);
                const seqLength = view.getUint8(offset++);
                const loopPoint = view.getInt32(offset, true);
                offset += 4;
                
                const seqData = [];
                for (let j = 0; j < seqLength && offset < arrayBuffer.byteLength; j++) {
                    seqData.push(view.getInt8(offset++));
                }
                
                sequences.push({
                    enabled: seqEnabled,
                    length: seqLength,
                    loop: loopPoint,
                    data: seqData
                });
            }
            
            // Extract duty cycle from duty sequence (usually sequence index 4)
            let dutyCycle = 2; // Default 50%
            if (sequences.length > 4 && sequences[4].enabled && sequences[4].data.length > 0) {
                dutyCycle = sequences[4].data[0]; // First duty cycle value
                console.log(`Instrument ${name}: duty sequence found, value = ${dutyCycle}`);
            } else {
                console.log(`Instrument ${name}: no duty sequence, using default = ${dutyCycle}`);
            }
            
            // Extract envelopes
            // Sequence 0 = Volume, 1 = Arpeggio, 2 = Pitch, 3 = Hi-pitch, 4 = Duty
            const volumeEnv = (sequences[0]?.enabled && sequences[0].data.length > 0) ? sequences[0] : null;
            const arpeggioEnv = (sequences[1]?.enabled && sequences[1].data.length > 0) ? sequences[1] : null;
            const pitchEnv = (sequences[2]?.enabled && sequences[2].data.length > 0) ? sequences[2] : null;
            const dutyEnv = (sequences[4]?.enabled && sequences[4].data.length > 0) ? sequences[4] : null;
            
            console.log(`Instrument ${name} envelopes:`, {
                volume: volumeEnv ? `${volumeEnv.data.length} steps` : 'none',
                arpeggio: arpeggioEnv ? `${arpeggioEnv.data.length} steps` : 'none',
                pitch: pitchEnv ? `${pitchEnv.data.length} steps` : 'none',
                duty: dutyEnv ? `${dutyEnv.data.length} steps` : 'none'
            });
            
            return {
                name: name,
                type: instType,
                sequences: sequences,
                dutyCycle: dutyCycle,
                volumeEnv: volumeEnv,
                arpeggioEnv: arpeggioEnv,
                pitchEnv: pitchEnv,
                dutyEnv: dutyEnv,
                color: `hsl(${Math.random() * 360}, 70%, 60%)`
            };
        }

        // Distinct color palette for instruments
        const instrumentColors = [
            '#00ff9f', // 1: Mint green (Default)
            '#ff6b9d', // 2: Pink
            '#ffd700', // 3: Gold
            '#00bfff', // 4: Sky blue
            '#ff6347', // 5: Tomato red
            '#9370db', // 6: Purple
            '#00fa9a', // 7: Spring green
            '#ff8c00', // 8: Dark orange
            '#1e90ff', // 9: Dodger blue
        ];
        
        function getInstrumentColor(id) {
            return instrumentColors[id - 1] || `hsl(${(id * 137.5) % 360}, 70%, 60%)`;
        }

        function addInstrument(instData = null) {
            const instId = nextInstrumentId++;
            const newInst = {
                id: instId,
                name: instData?.name || `Instrument ${instId}`,
                dutyCycle: instData?.dutyCycle ?? 2,
                color: instData?.color || getInstrumentColor(instId),
                // Store full envelope data from FTI
                volumeEnv: instData?.volumeEnv || null,
                arpeggioEnv: instData?.arpeggioEnv || null,
                pitchEnv: instData?.pitchEnv || null,
                dutyEnv: instData?.dutyEnv || null
            };
            instruments.push(newInst);
            renderInstrumentsList();
            return newInst;
        }

        function deleteInstrument(id) {
            if (id === 0) {
                alert('Cannot delete default instrument');
                return;
            }
            instruments = instruments.filter(inst => inst.id !== id);
            
            // Reset any notes using this instrument to default
            Object.keys(convertedTracks).forEach(channel => {
                if (convertedTracks[channel]?.notes) {
                    convertedTracks[channel].notes.forEach(note => {
                        if (note.instrument === id) {
                            note.instrument = 0;
                        }
                    });
                }
            });
            
            // Clear selection if deleting selected instrument
            if (selectedInstrumentForEditing === id) {
                selectedInstrumentForEditing = null;
                document.getElementById('instrumentEditorContent').innerHTML = `
                    <div style="text-align: center; color: var(--text-secondary); padding: 20px;">
                        Select an instrument to edit
                    </div>
                `;
            }
            
            renderInstrumentsList();
        }

        function updateInstrument(id, updates) {
            const inst = instruments.find(i => i.id === id);
            if (inst) {
                Object.assign(inst, updates);
                renderInstrumentsList();
                
                // If this is the currently selected instrument, refresh the editor
                if (selectedInstrumentForEditing === id) {
                    selectInstrumentForEditing(id);
                }
                
                // Re-render tracks to show color changes
                Object.keys(convertedTracks).forEach(channel => {
                    if (expandedTrack === channel) {
                        renderInlinePianoRoll(channel);
                    } else if (convertedTracks[channel]) {
                        visualizeTrack(channel, convertedTracks[channel]);
                    }
                });
            }
        }
        
        function initEnvelopeCanvas(canvasId, existingEnv, minVal, maxVal) {
            const canvas = document.getElementById(canvasId);
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            
            // Initialize envelope data
            if (!canvas.envelopeData) {
                if (existingEnv && existingEnv.data) {
                    canvas.envelopeData = [...existingEnv.data];
                } else {
                    canvas.envelopeData = [];
                }
            }
            
            function draw() {
                ctx.clearRect(0, 0, width, height);
                
                // Draw grid
                ctx.strokeStyle = 'rgba(0, 255, 159, 0.1)';
                ctx.lineWidth = 1;
                for (let i = 0; i <= 4; i++) {
                    const y = (height / 4) * i;
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(width, y);
                    ctx.stroke();
                }
                
                // Draw envelope
                if (canvas.envelopeData.length > 0) {
                    ctx.strokeStyle = '#00ff9f';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    
                    canvas.envelopeData.forEach((val, i) => {
                        const x = (i / 128) * width;
                        const normalizedVal = (val - minVal) / (maxVal - minVal);
                        const y = height - (normalizedVal * height);
                        
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    });
                    
                    ctx.stroke();
                    
                    // Draw points
                    ctx.fillStyle = '#00ff9f';
                    canvas.envelopeData.forEach((val, i) => {
                        const x = (i / 128) * width;
                        const normalizedVal = (val - minVal) / (maxVal - minVal);
                        const y = height - (normalizedVal * height);
                        ctx.beginPath();
                        ctx.arc(x, y, 3, 0, Math.PI * 2);
                        ctx.fill();
                    });
                }
            }
            
            let isDrawing = false;
            let shiftHeld = false;
            let altHeld = false;
            let lastDrawnValue = null;
            let lastDrawnIndex = -1;
            
            canvas.addEventListener('mousedown', (e) => {
                isDrawing = true;
                shiftHeld = e.shiftKey;
                altHeld = e.altKey;
                lastDrawnIndex = -1;
                addPoint(e);
            });
            
            canvas.addEventListener('mousemove', (e) => {
                if (isDrawing) {
                    shiftHeld = e.shiftKey;
                    altHeld = e.altKey;
                    addPoint(e);
                }
            });
            
            canvas.addEventListener('mouseup', () => {
                isDrawing = false;
                lastDrawnValue = null;
                lastDrawnIndex = -1;
            });
            
            canvas.addEventListener('mouseleave', () => {
                isDrawing = false;
                lastDrawnValue = null;
                lastDrawnIndex = -1;
            });
            
            function addPoint(e) {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                // Use the displayed canvas size, not the internal canvas size
                const displayWidth = rect.width;
                const displayHeight = rect.height;
                
                const index = Math.floor((x / displayWidth) * 128);
                const normalizedVal = 1 - (y / displayHeight);
                const val = Math.round(minVal + normalizedVal * (maxVal - minVal));
                
                if (index >= 0 && index < 128) {
                    // If shift is held, use the first drawn value for all points
                    const valueToUse = shiftHeld && lastDrawnValue !== null ? lastDrawnValue : val;
                    
                    // Store the first value when shift drawing starts
                    if (shiftHeld && lastDrawnValue === null) {
                        lastDrawnValue = val;
                    }
                    
                    // Extend array if needed
                    while (canvas.envelopeData.length <= index) {
                        canvas.envelopeData.push(minVal);
                    }
                    
                    // Fill in gaps between last drawn point and current point
                    if (lastDrawnIndex >= 0 && lastDrawnIndex !== index) {
                        const startIdx = Math.min(lastDrawnIndex, index);
                        const endIdx = Math.max(lastDrawnIndex, index);
                        const startVal = canvas.envelopeData[lastDrawnIndex];
                        
                        for (let i = startIdx; i <= endIdx; i++) {
                            if (altHeld) {
                                // Alt held: create staccato pattern (alternating between value and minVal)
                                canvas.envelopeData[i] = (i % 2 === 0) ? Math.max(minVal, Math.min(maxVal, valueToUse)) : minVal;
                            } else {
                                // Normal: linear interpolation between points
                                const t = (i - lastDrawnIndex) / (index - lastDrawnIndex);
                                const interpolatedVal = Math.round(startVal + t * (valueToUse - startVal));
                                canvas.envelopeData[i] = Math.max(minVal, Math.min(maxVal, interpolatedVal));
                            }
                        }
                    } else {
                        // First point or same index
                        if (altHeld) {
                            canvas.envelopeData[index] = (index % 2 === 0) ? Math.max(minVal, Math.min(maxVal, valueToUse)) : minVal;
                        } else {
                            canvas.envelopeData[index] = Math.max(minVal, Math.min(maxVal, valueToUse));
                        }
                    }
                    
                    lastDrawnIndex = index;
                    draw();
                    
                    // Auto-save envelope changes
                    autoSaveEnvelope(canvasId);
                }
            }
            
            draw();
        }
        
        function clearEnvelope(type) {
            const canvasId = `${type}EnvelopeCanvas`;
            const canvas = document.getElementById(canvasId);
            if (canvas) {
                canvas.envelopeData = [];
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Auto-save after clearing
                autoSaveEnvelope(canvasId);
            }
        }
        
        function autoSaveEnvelope(canvasId) {
            const inst = instruments.find(i => i.id === selectedInstrumentForEditing);
            if (!inst) return;
            
            const canvas = document.getElementById(canvasId);
            if (!canvas) return;
            
            // Determine which envelope based on canvas ID
            if (canvasId === 'volumeEnvelopeCanvas') {
                const loopInput = document.getElementById('volumeLoop');
                const loop = loopInput ? parseInt(loopInput.value) : -1;
                
                if (canvas.envelopeData && canvas.envelopeData.length > 0) {
                    inst.volumeEnv = {
                        enabled: true,
                        length: canvas.envelopeData.length,
                        loop: loop,
                        data: [...canvas.envelopeData]
                    };
                    console.log('Saved volume envelope:', inst.volumeEnv.data.length, 'points');
                } else {
                    inst.volumeEnv = null;
                }
            } else if (canvasId === 'arpeggioEnvelopeCanvas') {
                const loopInput = document.getElementById('arpeggioLoop');
                const loop = loopInput ? parseInt(loopInput.value) : -1;
                
                if (canvas.envelopeData && canvas.envelopeData.length > 0) {
                    inst.arpeggioEnv = {
                        enabled: true,
                        length: canvas.envelopeData.length,
                        loop: loop,
                        data: [...canvas.envelopeData]
                    };
                    console.log('Saved arpeggio envelope:', inst.arpeggioEnv.data.length, 'points');
                } else {
                    inst.arpeggioEnv = null;
                }
            } else if (canvasId === 'pitchEnvelopeCanvas') {
                const loopInput = document.getElementById('pitchLoop');
                const loop = loopInput ? parseInt(loopInput.value) : -1;
                
                if (canvas.envelopeData && canvas.envelopeData.length > 0) {
                    inst.pitchEnv = {
                        enabled: true,
                        length: canvas.envelopeData.length,
                        loop: loop,
                        data: [...canvas.envelopeData]
                    };
                    console.log('Saved pitch envelope:', inst.pitchEnv.data.length, 'points', inst.pitchEnv.data);
                } else {
                    inst.pitchEnv = null;
                }
            }
        }
        
        function saveEnvelopes() {
            const inst = instruments.find(i => i.id === selectedInstrumentForEditing);
            if (!inst) return;
            
            // Get canvas data
            const volCanvas = document.getElementById('volumeEnvelopeCanvas');
            const arpCanvas = document.getElementById('arpeggioEnvelopeCanvas');
            const pitCanvas = document.getElementById('pitchEnvelopeCanvas');
            
            // Get loop points
            const volLoop = parseInt(document.getElementById('volumeLoop').value);
            const arpLoop = parseInt(document.getElementById('arpeggioLoop').value);
            const pitLoop = parseInt(document.getElementById('pitchLoop').value);
            
            // Update instrument
            if (volCanvas.envelopeData && volCanvas.envelopeData.length > 0) {
                inst.volumeEnv = {
                    enabled: true,
                    length: volCanvas.envelopeData.length,
                    loop: volLoop,
                    data: volCanvas.envelopeData.filter((v, i) => i < volCanvas.envelopeData.length)
                };
            } else {
                inst.volumeEnv = null;
            }
            
            if (arpCanvas.envelopeData && arpCanvas.envelopeData.length > 0) {
                inst.arpeggioEnv = {
                    enabled: true,
                    length: arpCanvas.envelopeData.length,
                    loop: arpLoop,
                    data: arpCanvas.envelopeData.filter((v, i) => i < arpCanvas.envelopeData.length)
                };
            } else {
                inst.arpeggioEnv = null;
            }
            
            if (pitCanvas.envelopeData && pitCanvas.envelopeData.length > 0) {
                inst.pitchEnv = {
                    enabled: true,
                    length: pitCanvas.envelopeData.length,
                    loop: pitLoop,
                    data: pitCanvas.envelopeData.filter((v, i) => i < pitCanvas.envelopeData.length)
                };
            } else {
                inst.pitchEnv = null;
            }
            
            updateStatus(`üíæ Saved envelopes for ${inst.name}`);
        }
        
        function updateInstrument(id, updates) {
            const inst = instruments.find(i => i.id === id);
            if (inst) {
                Object.assign(inst, updates);
                renderInstrumentsList();
                
                // If this is the currently selected instrument, refresh the editor
                if (selectedInstrumentForEditing === id) {
                    selectInstrumentForEditing(id);
                }
                
                // Re-render tracks to show color changes
                Object.keys(convertedTracks).forEach(channel => {
                    if (expandedTrack === channel) {
                        renderInlinePianoRoll(channel);

                    } else if (convertedTracks[channel]) {
                        visualizeTrack(channel, convertedTracks[channel]);
                    }
                });
            }
        }

        let selectedInstrumentForEditing = null;
        let currentDrawingInstrument = 1; // Instrument to use when creating new notes
        
        function renderInstrumentsList() {
            const list = document.getElementById('instrumentsList');
            list.innerHTML = instruments.map(inst => {
                const isSelected = selectedInstrumentForEditing === inst.id;
                return `
                    <div onclick="event.stopPropagation(); selectInstrumentForEditing(${inst.id})" 
                         style="padding: 8px; margin-bottom: 4px; border-radius: 3px; border-left: 3px solid ${inst.color}; 
                                background: ${isSelected ? inst.color : 'var(--bg-mid)'}; 
                                cursor: pointer; font-size: 0.85rem; 
                                color: ${isSelected ? 'var(--bg-dark)' : 'var(--text-primary)'}; 
                                font-weight: ${isSelected ? 'bold' : 'normal'};">
                        ${inst.name}
                    </div>
                `;
            }).join('');
        }
        
        function previewInstrument(instId) {
            const inst = instruments.find(i => i.id === instId);
            if (!inst) return;
            
            // Stop any currently playing preview
            if (window.currentPreviewNodes) {
                window.currentPreviewNodes.forEach(node => {
                    try {
                        if (node.stop) node.stop();
                        if (node.disconnect) node.disconnect();
                    } catch (e) {
                        // Already stopped
                    }
                });
            }
            window.currentPreviewNodes = [];
            
            // Play a middle C (261.63 Hz) for 2.5 seconds to hear full envelope (128 frames @ 60fps = ~2.1s)
            playNotePreview('pulse1', 261.63, 2.5, instId);
        }
        
        function stopInstrumentPreview() {
            // Stop all currently playing preview nodes
            if (window.currentPreviewNodes) {
                window.currentPreviewNodes.forEach(node => {
                    try {
                        if (node.stop) node.stop();
                        if (node.disconnect) node.disconnect();
                    } catch (e) {
                        // Already stopped
                    }
                });
                window.currentPreviewNodes = [];
            }
        }
        
        function selectInstrumentForEditing(instId) {
            console.log('selectInstrumentForEditing called with:', instId, 'type:', typeof instId);
            selectedInstrumentForEditing = instId;
            const inst = instruments.find(i => i.id === instId);
            console.log('Found instrument:', inst);
            if (!inst) return;
            
            // Update selection highlight manually instead of re-rendering entire list
            document.querySelectorAll('#instrumentsList > div').forEach((el, idx) => {
                const instrument = instruments[idx];
                const isSelected = instrument.id === instId;
                el.style.background = isSelected ? instrument.color : 'var(--bg-mid)';
                el.style.color = isSelected ? 'var(--bg-dark)' : 'var(--text-primary)';
                el.style.fontWeight = isSelected ? 'bold' : 'normal';
            });
            
            const editorContent = document.getElementById('instrumentEditorContent');
            editorContent.innerHTML = `
                <!-- 2x2 Grid Layout -->
                <div style="display: grid; grid-template-columns: 1fr 1fr; grid-template-rows: 1fr 1fr; gap: 12px; flex: 1;">
                    
                    <!-- Top-Left: Instrument Settings -->
                    <div style="background: var(--bg-dark); border: 1px solid var(--accent-1); border-radius: 4px; padding: 10px; display: flex; flex-direction: column;">
                        <div style="margin-bottom: 8px;">
                            <label style="font-size: 0.75rem; color: var(--text-secondary); display: block; margin-bottom: 3px;">Instrument Name</label>
                            <input type="text" value="${inst.name}" 
                                   onchange="updateInstrument(${inst.id}, { name: this.value })"
                                   style="width: 100%; padding: 6px; background: var(--bg-mid); color: var(--text-primary); border: 1px solid var(--accent-1); border-radius: 3px; font-size: 0.85rem;">
                        </div>
                        
                        <div style="display: grid; grid-template-columns: 2fr 1fr; gap: 8px; margin-bottom: 8px;">
                            <div>
                                <label style="font-size: 0.75rem; color: var(--text-secondary); display: block; margin-bottom: 3px;">Duty Cycle</label>
                                <select onchange="updateInstrument(${inst.id}, { dutyCycle: parseInt(this.value) })" 
                                        style="width: 100%; padding: 6px; background: var(--bg-mid); color: var(--text-primary); border: 1px solid var(--accent-1); border-radius: 3px; font-size: 0.85rem;">
                                    <option value="0" ${inst.dutyCycle === 0 ? 'selected' : ''}>12.5%</option>
                                    <option value="1" ${inst.dutyCycle === 1 ? 'selected' : ''}>25%</option>
                                    <option value="2" ${inst.dutyCycle === 2 ? 'selected' : ''}>50%</option>
                                    <option value="3" ${inst.dutyCycle === 3 ? 'selected' : ''}>75%</option>
                                </select>
                            </div>
                            
                            <div>
                                <label style="font-size: 0.75rem; color: var(--text-secondary); display: block; margin-bottom: 3px;">Color</label>
                                <input type="color" value="${inst.color}" 
                                       onchange="updateInstrument(${inst.id}, { color: this.value })"
                                       style="width: 100%; height: 34px; cursor: pointer; border: 1px solid var(--accent-1); border-radius: 3px;">
                            </div>
                        </div>
                        
                        <!-- Loop Help Text -->
                        <div style="flex: 1; display: flex; align-items: flex-end;">
                            <div style="font-size: 0.6rem; color: var(--text-secondary); opacity: 0.7; line-height: 1.3;">
                                <div style="font-weight: bold; margin-bottom: 2px;">Envelope Loop:</div>
                                <div>-1 = no loop (one-shot)</div>
                                <div>0-127 = loop from frame (sustain)</div>
                            </div>
                        </div>
                        
                        ${inst.id !== 1 ? `
                            <button onclick="deleteInstrument(${inst.id})" 
                                    style="width: 100%; padding: 6px; font-size: 0.75rem; background: var(--accent-2); border: none; border-radius: 3px; cursor: pointer; color: white;">
                                üóëÔ∏è Delete
                            </button>
                        ` : ''}
                    </div>
                    
                    <!-- Top-Right: Volume Envelope -->
                    <div style="background: var(--bg-dark); border: 1px solid var(--accent-1); border-radius: 4px; padding: 10px; display: flex; flex-direction: column;">
                        <div style="font-size: 0.75rem; margin-bottom: 4px; color: var(--text-secondary);">Volume (0-15)</div>
                        <canvas id="volumeEnvelopeCanvas" width="280" height="80" style="flex: 1; width: 100%; border: 1px solid var(--accent-1); cursor: crosshair; background: var(--bg-mid); border-radius: 3px;"></canvas>
                        <div style="font-size: 0.65rem; margin-top: 4px; display: flex; gap: 6px; align-items: center;">
                            <button onclick="clearEnvelope('volume')" style="font-size: 0.65rem; padding: 2px 6px; background: var(--accent-2); border: none; border-radius: 2px; cursor: pointer; color: white;">Clear</button>
                            <label style="display: flex; align-items: center; gap: 3px; color: var(--text-secondary);">
                                Loop: <input type="number" id="volumeLoop" value="${inst.volumeEnv?.loop ?? -1}" min="-1" max="128" onchange="autoSaveEnvelope('volumeEnvelopeCanvas')" style="width: 40px; font-size: 0.65rem; padding: 1px; background: var(--bg-mid); color: var(--text-primary); border: 1px solid var(--accent-1); border-radius: 2px;">
                            </label>
                        </div>
                    </div>
                    
                    <!-- Bottom-Left: Arpeggio Envelope -->
                    <div style="background: var(--bg-dark); border: 1px solid var(--accent-1); border-radius: 4px; padding: 10px; display: flex; flex-direction: column;">
                        <div style="font-size: 0.75rem; margin-bottom: 4px; color: var(--text-secondary);">Arpeggio (semitones)</div>
                        <canvas id="arpeggioEnvelopeCanvas" width="280" height="80" style="flex: 1; width: 100%; border: 1px solid var(--accent-1); cursor: crosshair; background: var(--bg-mid); border-radius: 3px;"></canvas>
                        <div style="font-size: 0.65rem; margin-top: 4px; display: flex; gap: 6px; align-items: center;">
                            <button onclick="clearEnvelope('arpeggio')" style="font-size: 0.65rem; padding: 2px 6px; background: var(--accent-2); border: none; border-radius: 2px; cursor: pointer; color: white;">Clear</button>
                            <label style="display: flex; align-items: center; gap: 3px; color: var(--text-secondary);">
                                Loop: <input type="number" id="arpeggioLoop" value="${inst.arpeggioEnv?.loop ?? -1}" min="-1" max="128" onchange="autoSaveEnvelope('arpeggioEnvelopeCanvas')" style="width: 40px; font-size: 0.65rem; padding: 1px; background: var(--bg-mid); color: var(--text-primary); border: 1px solid var(--accent-1); border-radius: 2px;">
                            </label>
                        </div>
                    </div>
                    
                    <!-- Bottom-Right: Pitch Envelope -->
                    <div style="background: var(--bg-dark); border: 1px solid var(--accent-1); border-radius: 4px; padding: 10px; display: flex; flex-direction: column;">
                        <div style="font-size: 0.75rem; margin-bottom: 4px; color: var(--text-secondary);">Pitch (semitones)</div>
                        <canvas id="pitchEnvelopeCanvas" width="280" height="80" style="flex: 1; width: 100%; border: 1px solid var(--accent-1); cursor: crosshair; background: var(--bg-mid); border-radius: 3px;"></canvas>
                        <div style="font-size: 0.65rem; margin-top: 4px; display: flex; gap: 6px; align-items: center;">
                            <button onclick="clearEnvelope('pitch')" style="font-size: 0.65rem; padding: 2px 6px; background: var(--accent-2); border: none; border-radius: 2px; cursor: pointer; color: white;">Clear</button>
                            <label style="display: flex; align-items: center; gap: 3px; color: var(--text-secondary);">
                                Loop: <input type="number" id="pitchLoop" value="${inst.pitchEnv?.loop ?? -1}" min="-1" max="128" onchange="autoSaveEnvelope('pitchEnvelopeCanvas')" style="width: 40px; font-size: 0.65rem; padding: 1px; background: var(--bg-mid); color: var(--text-primary); border: 1px solid var(--accent-1); border-radius: 2px;">
                            </label>
                        </div>
                    </div>
                </div>
            `;
            
            // Initialize canvases
            setTimeout(() => {
                initEnvelopeCanvas('volumeEnvelopeCanvas', inst.volumeEnv, 0, 15);
                initEnvelopeCanvas('arpeggioEnvelopeCanvas', inst.arpeggioEnv, -12, 12);
                initEnvelopeCanvas('pitchEnvelopeCanvas', inst.pitchEnv, -12, 12);
            }, 50);
        }

        // Song length state
        let songLength = 30; // seconds
        
        // Calculate minimum zoom level so entire song fits in viewport
        function getMinZoomLevel() {
            // Get actual viewport width dynamically
            const viewportWidth = window.innerWidth || 1400;
            
            // Subtract piano keys (62px) from available playable width
            const pianoKeysWidth = 62;
            const availableWidth = viewportWidth - pianoKeysWidth - 100; // Extra margin for safety
            
            // We want: songLength * pixelsPerSecond <= availableWidth
            // So the entire song fits without scrolling
            // pixelsPerSecond = (zoomLevel / 100) * 50
            // Therefore: songLength * (zoomLevel / 100) * 50 <= availableWidth
            // So: zoomLevel <= (availableWidth * 100) / (songLength * 50)
            
            const maxZoomToFit = (availableWidth * 100) / (songLength * 50);
            
            // Return exact value needed to fit - no artificial minimum
            return maxZoomToFit;
        }

        // Quantization helper
        function snapToGrid(time) {
            const quantization = document.getElementById('noteQuantization').value;
            if (quantization === 'none') return time;
            
            // Notes are stored at 120 BPM reference timing
            const referenceBPM = 120;
            const beatDuration = 60 / referenceBPM; // 0.5s per beat at 120 BPM
            
            let gridSize;
            switch (quantization) {
                case 'eighth':
                    gridSize = beatDuration / 2; // 0.25s (8th notes)
                    break;
                case 'sixteenth':
                    gridSize = beatDuration / 4; // 0.125s (16th notes)
                    break;
                case 'thirtysecond':
                    gridSize = beatDuration / 8; // 0.0625s (32nd notes)
                    break;
                default:
                    return time;
            }
            
            // Snap to grid line at or before click position (floor)
            const snappedTime = Math.floor(time / gridSize) * gridSize;
            return snappedTime;
        }
        
        // Get note duration based on current quantization
        function getQuantizedNoteDuration() {
            const quantization = document.getElementById('noteQuantization').value;
            const referenceBPM = 120;
            const beatDuration = 60 / referenceBPM; // 0.5s per beat at 120 BPM
            
            switch (quantization) {
                case 'eighth':
                    return beatDuration / 2; // 0.25s (8th notes)
                case 'sixteenth':
                    return beatDuration / 4; // 0.125s (16th notes)
                case 'thirtysecond':
                    return beatDuration / 8; // 0.0625s (32nd notes)
                default:
                    return 0.25; // Default to 8th note
            }
        }

        // Playback system variables (declared early so keyboard handler can use them)
        let isPlaying = false;
        let playbackStartTime = 0;
        let pausedAtTime = 0; // Track where we paused
        let animationFrameId = null;
        let isLooping = false;
        let loopStart = 0;
        let loopEnd = 4;
        let soloedChannels = new Set(); // Track which channels are soloed (can be multiple)
        
        // MIDI variables
        let midiAccess = null;
        let isMidiRecording = false;
        let midiRecordStartTime = null;
        let midiActiveNotes = new Map(); // Track currently held notes: midiNote -> {startTime, frequency}
        let scheduledNotes = [];

        // NES frequency table (NTSC)
        const NES_FREQUENCIES = [
            // C, C#, D, D#, E, F, F#, G, G#, A, A#, B for octaves 2-7
            65.41, 69.30, 73.42, 77.78, 82.41, 87.31, 92.50, 98.00, 103.83, 110.00, 116.54, 123.47,
            130.81, 138.59, 146.83, 155.56, 164.81, 174.61, 185.00, 196.00, 207.65, 220.00, 233.08, 246.94,
            261.63, 277.18, 293.66, 311.13, 329.63, 349.23, 369.99, 392.00, 415.30, 440.00, 466.16, 493.88,
            523.25, 554.37, 587.33, 622.25, 659.25, 698.46, 739.99, 783.99, 830.61, 880.00, 932.33, 987.77,
            1046.50, 1108.73, 1174.66, 1244.51, 1318.51, 1396.91, 1479.98, 1567.98, 1661.22, 1760.00, 1864.66, 1975.53
        ];

        const NOTE_NAMES = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];

        function frequencyToNoteName(freq) {
            // Find closest NES frequency
            let closestIdx = 0;
            let minDiff = Math.abs(freq - NES_FREQUENCIES[0]);
            
            for (let i = 1; i < NES_FREQUENCIES.length; i++) {
                const diff = Math.abs(freq - NES_FREQUENCIES[i]);
                if (diff < minDiff) {
                    minDiff = diff;
                    closestIdx = i;
                }
            }
            
            const octave = Math.floor(closestIdx / 12) + 2;
            const note = NOTE_NAMES[closestIdx % 12];
            return `${note}${octave}`;
        }

        // DOM Elements
        const loadProjectBtn = document.getElementById('loadProjectBtn');
        const channelSelect = document.getElementById('channelSelect');
        const noteQuantization = document.getElementById('noteQuantization');
        const bpmInput = document.getElementById('bpmInput');
        const tapTempoBtn = document.getElementById('tapTempoBtn');
        const timeSignatureSelect = document.getElementById('timeSignature');
        const clickTrack = document.getElementById('clickTrack');
        const stemsList = document.getElementById('stemsList');
        const statusBar = document.getElementById('statusBar');
        const playBtn = document.getElementById('playBtn');
        const stopBtn = document.getElementById('stopBtn');
        const songLengthInput = document.getElementById('songLengthInput');
        const songLengthDisplay = { textContent: '' }; // Dummy object to prevent errors
        const exportBtn = document.getElementById('exportBtn');
        console.log('exportBtn:', exportBtn);
        const zoomDisplay = document.getElementById('zoomDisplay');
        
        // Song settings variables
        let bpm = 120;
        let timeSignature = 4; // 4/4 or 3/4
        
        // Quantization change listener
        if (noteQuantization) {
            noteQuantization.addEventListener('change', (e) => {
                // Re-render expanded piano roll if any
                if (expandedTrack) {
                    renderInlinePianoRoll(expandedTrack);
                }
                updateStatus(`Quantization: ${e.target.options[e.target.selectedIndex].text}`);
            });
        }
        
        // Time signature change listener
        if (timeSignatureSelect) {
            timeSignatureSelect.addEventListener('change', (e) => {
                timeSignature = parseInt(e.target.value);
                updateTimelineGrid();
                
                // Re-render expanded piano roll if any
                if (expandedTrack) {
                    renderInlinePianoRoll(expandedTrack);
                }
                
                updateStatus(`Time signature changed to ${timeSignature}/4`);
            });
        }
        
        // Update timeline grid based on BPM and time signature
        function updateTimelineGrid() {
            // Notes are stored at 120 BPM reference
            // Grid should show measures at that reference timing
            const referenceBPM = 120;
            const referenceBeatTime = 60 / referenceBPM; // 0.5s per beat
            const referenceMeasureTime = referenceBeatTime * timeSignature; // seconds per measure
            
            // Use base pixels per second (without tempo scaling)
            // Because notes are drawn at reference positions
            const measurePixels = referenceMeasureTime * pixelsPerSecond;
            const beatPixels = referenceBeatTime * pixelsPerSecond;
            
            console.log(`Grid updated: ${measurePixels}px per measure, ${beatPixels}px per beat (${timeSignature}/4, ref measure time: ${referenceMeasureTime}s, pixelsPerSecond: ${pixelsPerSecond})`);
        }
        
        // ============================================
        // BEAT/TIME CONVERSION (for BPM-based tempo)
        // ============================================

        // Zoom state (must be declared before functions that use it)
        let zoomLevel = 200; // percentage, 100% displayed = 100px per second (internally 200%)
        let pixelsPerSecond = 100; // base scale (doubled from original 50)
        
        // Convert beats to seconds based on current BPM
        function beatsToSeconds(beats) {
            return (beats * 60) / bpm;
        }
        
        // Convert seconds to beats based on current BPM
        function secondsToBeats(seconds) {
            return (seconds * bpm) / 60;
        }
        
        // Get pixels per second scaled for current BPM (notes stored at 120 BPM reference)
        function getScaledPixelsPerSecond() {
            const referenceBPM = 120;
            const tempoScale = referenceBPM / bpm;
            return pixelsPerSecond * tempoScale;
        }
        
        // Call on page load (after all variables are defined)
        updateTimelineGrid();
        
        // Track expansion state
        let expandedTrack = null;
        const hasAutoScrolled = {}; // Track which channels have been scrolled to middle C

        // Drag selection state
        let isDragSelecting = false;
        let dragSelectStart = { x: 0, y: 0 };
        let dragSelectChannel = null;
        let userDidDrag = false; // Track if user actually moved mouse during drag

        // Note name to frequency mapping
        const noteNameToFreq = {
            'C': 0, 'C#': 1, 'D': 2, 'D#': 3, 'E': 4, 'F': 5,
            'F#': 6, 'G': 7, 'G#': 8, 'A': 9, 'A#': 10, 'B': 11
        };

        function parseNoteName(noteName) {
            if (!noteName || noteName === '...' || noteName === '---') return null;
            
            // Format: "D-3" or "C#4"
            const match = noteName.match(/^([A-G]#?)(-?)(\d+)$/);
            if (!match) return null;
            
            const note = match[1];
            const octave = parseInt(match[3]);
            
            const noteIndex = noteNameToFreq[note];
            if (noteIndex === undefined) return null;
            
            // Calculate frequency index in NES_FREQUENCIES array
            // Octave 2 starts at index 0, octave 3 at index 12, etc.
            const freqIndex = (octave - 2) * 12 + noteIndex;
            
            if (freqIndex < 0 || freqIndex >= NES_FREQUENCIES.length) return null;
            
            return NES_FREQUENCIES[freqIndex];
        }

        function frequencyToFamiTrackerNote(frequency) {
            // Find closest NES frequency
            let closestIdx = 0;
            let minDiff = Math.abs(frequency - NES_FREQUENCIES[0]);
            
            for (let i = 1; i < NES_FREQUENCIES.length; i++) {
                const diff = Math.abs(frequency - NES_FREQUENCIES[i]);
                if (diff < minDiff) {
                    minDiff = diff;
                    closestIdx = i;
                }
            }
            
            const octave = Math.floor(closestIdx / 12) + 2;
            const noteIdx = closestIdx % 12;
            const noteName = NOTE_NAMES[noteIdx];
            
            return `${noteName.replace('#', '#')}-${octave}`;
        }

        function exportToFamiTracker(metadata = {}) {
            const bpm = parseInt(bpmInput.value);
            const secondsPerRow = 60 / (bpm * 4);
            const totalRows = Math.ceil(songLength / secondsPerRow);
            
            const title = metadata.title || "Untitled Song";
            const author = metadata.author || "";
            const copyright = metadata.copyright || new Date().getFullYear().toString();
            const comment = metadata.comment || "";
            
            let output = `# NES Music Maker export

# Song information
TITLE           "${title}"
AUTHOR          "${author}"
COPYRIGHT       "${copyright}"

# Song comment
COMMENT         "${comment}"

# Global settings
MACHINE         0
FRAMERATE       0
EXPANSION       0
VIBRATO         1
SPLIT           32

# Macros
`;
            
            // Export all macros/sequences from instruments
            const macroCounters = { 0: 0, 1: 0, 2: 0, 4: 0 }; // Separate counter for each type
            const instrumentMacroMap = {}; // Map instrument ID to macro indices
            
            instruments.forEach((inst, idx) => {
                instrumentMacroMap[inst.id] = {
                    volSeq: -1,
                    arpSeq: -1,
                    pitchSeq: -1,
                    dutySeq: -1
                };
                
                // Volume envelope
                if (inst.volumeEnv && inst.volumeEnv.data && inst.volumeEnv.data.length > 0) {
                    const loop = inst.volumeEnv.loop ?? -1;
                    const macroIdx = macroCounters[0];
                    output += `MACRO       0   ${macroIdx}  ${loop}  -1   0 : ${inst.volumeEnv.data.join(' ')}\n`;
                    instrumentMacroMap[inst.id].volSeq = macroIdx;
                    macroCounters[0]++;
                }
                
                // Arpeggio envelope
                if (inst.arpeggioEnv && inst.arpeggioEnv.data && inst.arpeggioEnv.data.length > 0) {
                    const loop = inst.arpeggioEnv.loop ?? -1;
                    const macroIdx = macroCounters[1];
                    output += `MACRO       1   ${macroIdx}  ${loop}  -1   0 : ${inst.arpeggioEnv.data.join(' ')}\n`;
                    instrumentMacroMap[inst.id].arpSeq = macroIdx;
                    macroCounters[1]++;
                }
                
                // Pitch envelope
                if (inst.pitchEnv && inst.pitchEnv.data && inst.pitchEnv.data.length > 0) {
                    const loop = inst.pitchEnv.loop ?? -1;
                    const macroIdx = macroCounters[2];
                    output += `MACRO       2   ${macroIdx}  ${loop}  -1   0 : ${inst.pitchEnv.data.join(' ')}\n`;
                    instrumentMacroMap[inst.id].pitchSeq = macroIdx;
                    macroCounters[2]++;
                }
                
                // Duty envelope (using dutyCycle as a single-value envelope)
                if (inst.dutyCycle !== undefined) {
                    const macroIdx = macroCounters[4];
                    output += `MACRO       4   ${macroIdx}  -1  -1   0 : ${inst.dutyCycle}\n`;
                    instrumentMacroMap[inst.id].dutySeq = macroIdx;
                    macroCounters[4]++;
                }
            });
            
            output += `
# DPCM samples

# Instruments
`;
            
            // Export all instruments
            instruments.forEach((inst, idx) => {
                const map = instrumentMacroMap[inst.id];
                output += `INST2A03   ${idx}     ${map.volSeq}  ${map.arpSeq}  ${map.pitchSeq}  -1  ${map.dutySeq} "${inst.name}"\n`;
            });
            
            output += `
# Tracks

TRACK 256   6 ${bpm} "${title}"
COLUMNS : 1 1 1 1 1

ORDER 00 : 00 00 00 00 00

PATTERN 00
`;
            
            // Create a map of time to notes for each channel
            const channelNotes = {
                pulse1: {},
                pulse2: {},
                triangle: {},
                noise: {}
            };
            
            // Populate note maps - ensure no overlapping notes (NES can only play one note at a time per channel)
            Object.keys(convertedTracks).forEach(channel => {
                const track = convertedTracks[channel];
                if (track && track.notes) {
                    // Sort notes by time to process them in order
                    const sortedNotes = [...track.notes].sort((a, b) => a.time - b.time);
                    
                    sortedNotes.forEach((note, idx) => {
                        let row = Math.round(note.time / secondsPerRow);
                        
                        if (row >= 0 && row < totalRows) {
                            // Check if there's already a note at this row
                            if (channelNotes[channel][row]) {
                                // Find the next empty row
                                while (channelNotes[channel][row] && row < totalRows) {
                                    row++;
                                }
                            }
                            
                            if (row < totalRows) {
                                channelNotes[channel][row] = note;
                                
                                // Cut off any previous notes that would overlap with this one
                                // Check all previous rows and shorten notes that extend into this row's time
                                const noteStartTime = row * secondsPerRow;
                                for (let prevRow = 0; prevRow < row; prevRow++) {
                                    const prevNote = channelNotes[channel][prevRow];
                                    if (prevNote) {
                                        const prevNoteEndTime = prevNote.time + prevNote.duration;
                                        if (prevNoteEndTime > noteStartTime) {
                                            // Previous note overlaps - cut it off
                                            const newDuration = noteStartTime - prevNote.time;
                                            if (newDuration > 0) {
                                                prevNote.duration = newDuration;
                                            } else {
                                                // If new duration would be 0 or negative, remove the note
                                                delete channelNotes[channel][prevRow];
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    });
                }
            });
            
            // Generate rows
            for (let row = 0; row < totalRows; row++) {
                const rowHex = row.toString(16).toUpperCase().padStart(2, '0');
                const currentRowTime = row * secondsPerRow;
                
                // Helper function to check if a note should be released at this row
                const shouldCutNote = (channel, row) => {
                    // Find the most recent note before this row
                    for (let prevRow = row - 1; prevRow >= 0; prevRow--) {
                        if (channelNotes[channel][prevRow]) {
                            const prevNote = channelNotes[channel][prevRow];
                            const prevNoteStartTime = prevRow * secondsPerRow;
                            const prevNoteEndTime = prevNoteStartTime + prevNote.duration;
                            const currentRowTime = row * secondsPerRow;
                            
                            // Check if the note should end at or before this row
                            // Use a small tolerance to account for rounding
                            const tolerance = secondsPerRow * 0.1;
                            if (prevNoteEndTime <= currentRowTime + tolerance && 
                                prevNoteEndTime >= currentRowTime - tolerance) {
                                return true;
                            }
                            break;
                        }
                    }
                    return false;
                };
                
                // Pulse 1
                let p1 = '... .. . ...';
                if (channelNotes.pulse1[row]) {
                    const note = channelNotes.pulse1[row];
                    const noteName = frequencyToFamiTrackerNote(note.frequency);
                    const instIdx = instruments.findIndex(i => i.id === (note.instrument || 1));
                    const instHex = (instIdx >= 0 ? instIdx : 0).toString(16).toUpperCase().padStart(2, '0');
                    p1 = `${noteName.padEnd(3)} ${instHex} . ...`;
                } else if (shouldCutNote('pulse1', row)) {
                    p1 = '--- .. . ...'; // Note release
                }
                
                // Pulse 2
                let p2 = '... .. . ...';
                if (channelNotes.pulse2[row]) {
                    const note = channelNotes.pulse2[row];
                    const noteName = frequencyToFamiTrackerNote(note.frequency);
                    const instIdx = instruments.findIndex(i => i.id === (note.instrument || 1));
                    const instHex = (instIdx >= 0 ? instIdx : 0).toString(16).toUpperCase().padStart(2, '0');
                    p2 = `${noteName.padEnd(3)} ${instHex} . ...`;
                } else if (shouldCutNote('pulse2', row)) {
                    p2 = '--- .. . ...'; // Note release
                }
                
                // Triangle
                let tri = '... .. . ...';
                if (channelNotes.triangle[row]) {
                    const note = channelNotes.triangle[row];
                    const noteName = frequencyToFamiTrackerNote(note.frequency);
                    const instIdx = instruments.findIndex(i => i.id === (note.instrument || 1));
                    const instHex = (instIdx >= 0 ? instIdx : 0).toString(16).toUpperCase().padStart(2, '0');
                    tri = `${noteName.padEnd(3)} ${instHex} . ...`;
                } else if (shouldCutNote('triangle', row)) {
                    tri = '--- .. . ...'; // Note release
                }
                
                // Noise
                let noise = '... .. . ...';
                if (channelNotes.noise[row]) {
                    const note = channelNotes.noise[row];
                    const instIdx = instruments.findIndex(i => i.id === (note.instrument || 1));
                    const instHex = (instIdx >= 0 ? instIdx : 0).toString(16).toUpperCase().padStart(2, '0');
                    noise = `8-# ${instHex} . ...`;
                } else if (shouldCutNote('noise', row)) {
                    noise = '--- .. . ...'; // Note release
                }
                
                output += `ROW ${rowHex} : ${p1} : ${p2} : ${tri} : ${noise} : ... .. . ...\n`;
            }
            
            output += '\n# End of export\n';
            
            return output;
        }

        if (exportBtn) {
            exportBtn.addEventListener('click', () => {
                // Show the export modal
                const modal = document.getElementById('exportModal');
                modal.style.display = 'flex';
                
                // Pre-fill copyright with current year if empty
                const copyrightInput = document.getElementById('exportCopyright');
                if (!copyrightInput.value) {
                    copyrightInput.value = new Date().getFullYear().toString();
                }
                
                // Focus on title input
                document.getElementById('exportTitle').focus();
                document.getElementById('exportTitle').select();
            });
        }
        
        // Export modal handlers (set up once DOM is loaded)
        document.addEventListener('DOMContentLoaded', () => {
            const exportCancelBtn = document.getElementById('exportCancelBtn');
            const exportConfirmBtn = document.getElementById('exportConfirmBtn');
            const exportModal = document.getElementById('exportModal');
            
            if (exportCancelBtn) {
                exportCancelBtn.addEventListener('click', () => {
                    exportModal.style.display = 'none';
                });
            }
            
            if (exportConfirmBtn) {
                exportConfirmBtn.addEventListener('click', () => {
                    try {
                        const metadata = {
                            title: document.getElementById('exportTitle').value,
                            author: document.getElementById('exportAuthor').value,
                            copyright: document.getElementById('exportCopyright').value,
                            comment: document.getElementById('exportComment').value
                        };
                        
                        const famiTrackerText = exportToFamiTracker(metadata);
                        
                        // Create download
                        const blob = new Blob([famiTrackerText], { type: 'text/plain' });
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        const filename = metadata.title.replace(/[^a-z0-9]/gi, '_').toLowerCase() || 'export';
                        a.download = `${filename}.txt`;
                        a.click();
                        URL.revokeObjectURL(url);
                        
                        // Hide modal
                        exportModal.style.display = 'none';
                        
                        updateStatus('‚úì Exported to FamiTracker format');
                    } catch (error) {
                        console.error('Export error:', error);
                        updateStatus(`‚úó Export error: ${error.message}`);
                    }
                });
            }
            
            // Allow Enter key in export modal to confirm
            if (exportModal) {
                exportModal.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' && e.target.tagName !== 'TEXTAREA') {
                        e.preventDefault();
                        exportConfirmBtn.click();
                    }
                    if (e.key === 'Escape') {
                        exportModal.style.display = 'none';
                    }
                });
            }
        });

        // Parse binary FTM (FamiTracker Module) files
        function parseFamiTracker(fileContent) {
            const lines = fileContent.split('\n');
            const tracks = {
                pulse1: { notes: [], duration: 0 },
                pulse2: { notes: [], duration: 0 },
                triangle: { notes: [], duration: 0 },
                noise: { notes: [], duration: 0 }
            };
            
            // Parse instruments first
            const parsedInstruments = {};
            const parsedMacros = {}; // Store older MACRO format sequences
            let currentInstIndex = null;
            
            // First pass: Parse MACRO definitions (older format)
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                
                if (line.startsWith('MACRO')) {
                    // Format: MACRO [type] [index] [loop] [release] [setting] : [values...]
                    const match = line.match(/MACRO\s+(\d+)\s+(\d+)\s+(-?\d+)\s+(-?\d+)\s+(-?\d+)\s+:\s+(.+)/);
                    if (match) {
                        const type = parseInt(match[1]);
                        const index = parseInt(match[2]);
                        const values = match[6].trim().split(/\s+/).map(v => parseInt(v));
                        
                        if (!parsedMacros[type]) parsedMacros[type] = {};
                        parsedMacros[type][index] = values;
                    }
                }
            }
            
            console.log('Parsed MACRO sequences:', parsedMacros);
            
            // Second pass: Parse instruments
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                
                // Parse instrument definition
                if (line.startsWith('INST2A03')) {
                    // Format: INST2A03 [index] [vol] [arp] [pitch] [hi-pitch] [duty] "Name"
                    const match = line.match(/INST2A03\s+(\d+)\s+(-?\d+)\s+(-?\d+)\s+(-?\d+)\s+(-?\d+)\s+(-?\d+)\s+"([^"]+)"/);
                    if (match) {
                        currentInstIndex = parseInt(match[1]);
                        parsedInstruments[currentInstIndex] = {
                            index: currentInstIndex,
                            name: match[7],
                            volumeSeq: match[2] !== '-1' ? parseInt(match[2]) : -1,
                            arpeggioSeq: match[3] !== '-1' ? parseInt(match[3]) : -1,
                            pitchSeq: match[4] !== '-1' ? parseInt(match[4]) : -1,
                            dutySeq: match[6] !== '-1' ? parseInt(match[6]) : -1,
                            volumeEnvelope: [],
                            arpeggioEnvelope: [],
                            pitchEnvelope: [],
                            dutyEnvelope: []
                        };
                    }
                }
                
                // Parse instrument macros (envelopes)
                if (line.startsWith('INSTMACRO') && currentInstIndex !== null) {
                    // Format: INSTMACRO [type] [loop] [release] : [values...]
                    const match = line.match(/INSTMACRO\s+(\d+)\s+(-?\d+)\s+(-?\d+)\s+:\s+(.+)/);
                    if (match) {
                        const type = parseInt(match[1]);
                        const values = match[4].trim().split(/\s+/).map(v => parseInt(v));
                        
                        if (parsedInstruments[currentInstIndex]) {
                            switch(type) {
                                case 0: // Volume envelope
                                    parsedInstruments[currentInstIndex].volumeEnvelope = values;
                                    break;
                                case 1: // Arpeggio
                                    parsedInstruments[currentInstIndex].arpeggioEnvelope = values;
                                    break;
                                case 2: // Pitch
                                    parsedInstruments[currentInstIndex].pitchEnvelope = values;
                                    break;
                                case 4: // Duty cycle
                                    parsedInstruments[currentInstIndex].dutyEnvelope = values;
                                    break;
                            }
                        }
                    }
                }
            }
            
            console.log('Parsed instruments:', parsedInstruments);
            
            // Add instruments to the editor's instrument list
            Object.values(parsedInstruments).forEach(inst => {
                // If envelopes are empty, try to load from MACRO sequences
                if (inst.volumeEnvelope.length === 0 && inst.volumeSeq >= 0 && parsedMacros[0] && parsedMacros[0][inst.volumeSeq]) {
                    inst.volumeEnvelope = parsedMacros[0][inst.volumeSeq];
                }
                if (inst.arpeggioEnvelope.length === 0 && inst.arpeggioSeq >= 0 && parsedMacros[1] && parsedMacros[1][inst.arpeggioSeq]) {
                    inst.arpeggioEnvelope = parsedMacros[1][inst.arpeggioSeq];
                }
                if (inst.pitchEnvelope.length === 0 && inst.pitchSeq >= 0 && parsedMacros[2] && parsedMacros[2][inst.pitchSeq]) {
                    inst.pitchEnvelope = parsedMacros[2][inst.pitchSeq];
                }
                if (inst.dutyEnvelope.length === 0 && inst.dutySeq >= 0 && parsedMacros[4] && parsedMacros[4][inst.dutySeq]) {
                    inst.dutyEnvelope = parsedMacros[4][inst.dutySeq];
                }
                
                // Create instrument in editor format
                const editorInst = {
                    id: instruments.length + 1,
                    name: inst.name,
                    color: `hsl(${(instruments.length * 60) % 360}, 70%, 60%)`,
                    // Convert envelopes to proper format for playback
                    volumeEnv: inst.volumeEnvelope.length > 0 ? {
                        data: inst.volumeEnvelope,
                        loop: -1
                    } : null,
                    arpeggioEnv: inst.arpeggioEnvelope.length > 0 ? {
                        data: inst.arpeggioEnvelope,
                        loop: -1
                    } : null,
                    pitchEnv: inst.pitchEnvelope.length > 0 ? {
                        data: inst.pitchEnvelope,
                        loop: -1
                    } : null,
                    // Use first duty value as dutyCycle, or default to 2
                    dutyCycle: inst.dutyEnvelope.length > 0 ? inst.dutyEnvelope[0] : 2,
                    // Store full envelopes for editing
                    volumeEnvelope: inst.volumeEnvelope.length > 0 ? inst.volumeEnvelope : [15],
                    dutyEnvelope: inst.dutyEnvelope.length > 0 ? inst.dutyEnvelope : [2],
                    arpeggioEnvelope: inst.arpeggioEnvelope,
                    pitchEnvelope: inst.pitchEnvelope
                };
                
                // Map FamiTracker index to editor ID
                inst.editorId = editorInst.id;
                
                instruments.push(editorInst);
                console.log(`Added instrument: FT index ${inst.index} -> Editor ID ${editorInst.id}, name: "${editorInst.name}"`);
                console.log('  Volume envelope:', editorInst.volumeEnvelope);
                console.log('  Arpeggio envelope:', editorInst.arpeggioEnvelope);
                console.log('  Pitch envelope:', editorInst.pitchEnvelope);
                console.log('  Duty envelope:', editorInst.dutyEnvelope);
            });
            
            // Update instruments UI
            renderInstrumentsList();
            
            let rowCount = 0;
            
            // Parse tempo
            for (let line of lines) {
                if (line.startsWith('TRACK')) {
                    const match = line.match(/TRACK\s+\d+\s+\d+\s+(\d+)/);
                    if (match) {
                        bpm = parseInt(match[1]);
                        bpmInput.value = bpm;
                    }
                }
            }
            
            // Calculate time per row (in seconds)
            const secondsPerRow = 60 / (bpm * 4); // 4 rows per beat at default speed
            
            // Parse pattern data
            let inPattern = false;
            let currentRow = 0;
            
            for (let line of lines) {
                if (line.startsWith('PATTERN')) {
                    inPattern = true;
                    currentRow = 0;
                    continue;
                }
                
                if (line.startsWith('# End of export') || line.startsWith('ORDER')) {
                    inPattern = false;
                    continue;
                }
                
                if (inPattern && line.startsWith('ROW')) {
                    // Format: ROW 00 : D-3 00 . ... : F-3 00 . ... : ... .. . ... : 8-# 03 . ... : ... .. . ...
                    const parts = line.split(':');
                    if (parts.length < 5) continue;
                    
                    const rowMatch = parts[0].match(/ROW ([0-9A-F]+)/);
                    if (!rowMatch) continue;
                    
                    const rowNum = parseInt(rowMatch[1], 16);
                    const time = rowNum * secondsPerRow;
                    
                    // Column 1: Pulse 1
                    const pulse1Data = parts[1].trim().split(/\s+/);
                    if (pulse1Data[0] === '---') {
                        // Note release - find the last note and cut it off at this row
                        if (tracks.pulse1.notes.length > 0) {
                            const lastNote = tracks.pulse1.notes[tracks.pulse1.notes.length - 1];
                            lastNote.duration = time - lastNote.time;
                        }
                    } else {
                        const pulse1Note = parseNoteName(pulse1Data[0]);
                        if (pulse1Note) {
                            // New note starting - cut off the previous note if it exists
                            if (tracks.pulse1.notes.length > 0) {
                                const lastNote = tracks.pulse1.notes[tracks.pulse1.notes.length - 1];
                                // Only cut if the previous note would extend past this new note
                                if (lastNote.time + lastNote.duration > time) {
                                    lastNote.duration = time - lastNote.time;
                                }
                            }
                            
                            const instIndex = pulse1Data[1] !== '..' ? parseInt(pulse1Data[1], 16) : null;
                            const note = {
                                frequency: pulse1Note,
                                time: time,
                                duration: secondsPerRow * 4,
                                velocity: 0.8
                            };
                            // Map FamiTracker instrument index to editor instrument ID
                            if (instIndex !== null && parsedInstruments[instIndex]) {
                                note.instrument = parsedInstruments[instIndex].editorId || 1;
                                if (currentRow === rowNum) { // Only log once per pattern
                                    console.log(`  Note at row ${rowNum}: FT inst ${instIndex} -> Editor ID ${note.instrument}`);
                                }
                            } else if (instIndex !== null) {
                                console.warn(`  Warning: Note references instrument ${instIndex} but it wasn't found in parsedInstruments`);
                            }
                            tracks.pulse1.notes.push(note);
                        }
                    }
                    
                    // Column 2: Pulse 2
                    const pulse2Data = parts[2].trim().split(/\s+/);
                    if (pulse2Data[0] === '---') {
                        // Note release
                        if (tracks.pulse2.notes.length > 0) {
                            const lastNote = tracks.pulse2.notes[tracks.pulse2.notes.length - 1];
                            lastNote.duration = time - lastNote.time;
                        }
                    } else {
                        const pulse2Note = parseNoteName(pulse2Data[0]);
                        if (pulse2Note) {
                            // New note starting - cut off the previous note
                            if (tracks.pulse2.notes.length > 0) {
                                const lastNote = tracks.pulse2.notes[tracks.pulse2.notes.length - 1];
                                if (lastNote.time + lastNote.duration > time) {
                                    lastNote.duration = time - lastNote.time;
                                }
                            }
                            
                            const instIndex = pulse2Data[1] !== '..' ? parseInt(pulse2Data[1], 16) : null;
                            const note = {
                                frequency: pulse2Note,
                                time: time,
                                duration: secondsPerRow * 4,
                                velocity: 0.8
                            };
                            if (instIndex !== null && parsedInstruments[instIndex]) {
                                note.instrument = parsedInstruments[instIndex].editorId || 1;
                            }
                            tracks.pulse2.notes.push(note);
                        }
                    }
                    
                    // Column 3: Triangle
                    const triangleData = parts[3].trim().split(/\s+/);
                    if (triangleData[0] === '---') {
                        // Note release
                        if (tracks.triangle.notes.length > 0) {
                            const lastNote = tracks.triangle.notes[tracks.triangle.notes.length - 1];
                            lastNote.duration = time - lastNote.time;
                        }
                    } else {
                        const triangleNote = parseNoteName(triangleData[0]);
                        if (triangleNote) {
                            // New note starting - cut off the previous note
                            if (tracks.triangle.notes.length > 0) {
                                const lastNote = tracks.triangle.notes[tracks.triangle.notes.length - 1];
                                if (lastNote.time + lastNote.duration > time) {
                                    lastNote.duration = time - lastNote.time;
                                }
                            }
                            
                            const instIndex = triangleData[1] !== '..' ? parseInt(triangleData[1], 16) : null;
                            const note = {
                                frequency: triangleNote,
                                time: time,
                                duration: secondsPerRow * 4,
                                velocity: 0.8
                            };
                            if (instIndex !== null && parsedInstruments[instIndex]) {
                                note.instrument = parsedInstruments[instIndex].editorId || 1;
                            }
                            tracks.triangle.notes.push(note);
                        }
                    }
                    
                    // Column 4: Noise
                    const noiseData = parts[4].trim().split(/\s+/);
                    if (noiseData[0] === '---') {
                        // Note release
                        if (tracks.noise.notes.length > 0) {
                            const lastNote = tracks.noise.notes[tracks.noise.notes.length - 1];
                            lastNote.duration = time - lastNote.time;
                        }
                    } else if (noiseData[0] !== '...') {
                        // New note starting - cut off the previous note
                        if (tracks.noise.notes.length > 0) {
                            const lastNote = tracks.noise.notes[tracks.noise.notes.length - 1];
                            if (lastNote.time + lastNote.duration > time) {
                                lastNote.duration = time - lastNote.time;
                            }
                        }
                        
                        const instIndex = noiseData[1] !== '..' ? parseInt(noiseData[1], 16) : null;
                        const note = {
                            frequency: 440, // Dummy frequency for noise
                            time: time,
                            duration: secondsPerRow,
                            velocity: 0.8
                        };
                        if (instIndex !== null && parsedInstruments[instIndex]) {
                            note.instrument = parsedInstruments[instIndex].editorId || 1;
                        }
                        tracks.noise.notes.push(note);
                    }
                    
                    currentRow = Math.max(currentRow, rowNum + 1);
                }
            }
            
            // Calculate total duration
            const totalDuration = currentRow * secondsPerRow;
            tracks.pulse1.duration = totalDuration;
            tracks.pulse2.duration = totalDuration;
            tracks.triangle.duration = totalDuration;
            tracks.noise.duration = totalDuration;
            
            // Update song length
            songLength = Math.ceil(totalDuration);
            songLengthInput.value = songLength;
            songLengthDisplay.textContent = `${songLength.toFixed(1)}s`;
            
            return tracks;
        }

        // Microphone recording state
        let isRecording = false;
        let mediaStream = null;
        let audioAnalyzer = null;
        let recordingStartTime = 0;
        let recordedNotes = [];
        let metronomeInterval = null;

        // Tap tempo state
        let tapTimes = [];
        let tapTimeout = null;

        // Track elements
        const trackElements = {
            pulse1: document.getElementById('pulse1Track'),
            pulse2: document.getElementById('pulse2Track'),
            triangle: document.getElementById('triangleTrack'),
            noise: document.getElementById('noiseTrack')
        };

        // Synchronize horizontal scroll across all tracks
        let isScrollSyncing = false; // Prevent infinite loop
        Object.keys(trackElements).forEach(channel => {
            const trackContent = trackElements[channel];
            trackContent.addEventListener('scroll', (e) => {
                if (isScrollSyncing) return;
                
                isScrollSyncing = true;
                const scrollLeft = trackContent.scrollLeft;
                
                // Sync scroll position to all other tracks
                Object.keys(trackElements).forEach(otherChannel => {
                    if (otherChannel !== channel) {
                        trackElements[otherChannel].scrollLeft = scrollLeft;
                    }
                });
                
                isScrollSyncing = false;
            });
        });

        // Initialize empty tracks
        Object.keys(convertedTracks).forEach(channel => {
            convertedTracks[channel] = {
                notes: [],
                duration: songLength
            };
        });

        // Undo/Redo system
        const undoStack = {};
        const redoStack = {};
        
        function saveUndoState(channel) {
            if (!undoStack[channel]) undoStack[channel] = [];
            if (!redoStack[channel]) redoStack[channel] = [];
            
            undoStack[channel].push(JSON.parse(JSON.stringify(convertedTracks[channel])));
            redoStack[channel] = []; // Clear redo when new action is made
            
            // Limit undo stack to 50 states
            if (undoStack[channel].length > 50) {
                undoStack[channel].shift();
            }
        }

        function undo(channel) {
            channel = channel || selectedChannel;
            
            if (!channel) {
                updateStatus('No channel selected for undo');
                return;
            }
            
            if (undoStack[channel] && undoStack[channel].length > 0) {
                console.log('UNDO: Saving current state to redo stack');
                redoStack[channel].push(JSON.parse(JSON.stringify(convertedTracks[channel])));
                
                console.log('UNDO: Restoring state from undo stack');
                convertedTracks[channel] = undoStack[channel].pop();
                console.log('UNDO: Restored state has', convertedTracks[channel].notes.length, 'notes');
                
                if (expandedTrack === channel) {
                    console.log('UNDO: Calling renderInlinePianoRoll');
                    renderInlinePianoRoll(channel);
                    console.log('UNDO: After render, track has', convertedTracks[channel].notes.length, 'notes');
                } else {
                    visualizeTrack(channel, convertedTracks[channel]);
                }
                
                updateStatus(`‚Ü∂ Undo on ${channel.toUpperCase()}`);
            } else {
                updateStatus(`No more undo history for ${channel.toUpperCase()}`);
            }
        }

        function redo(channel) {
            channel = channel || selectedChannel;
            if (!channel) {
                updateStatus('No channel selected for redo');
                return;
            }
            
            if (redoStack[channel] && redoStack[channel].length > 0) {
                undoStack[channel].push(JSON.parse(JSON.stringify(convertedTracks[channel])));
                convertedTracks[channel] = redoStack[channel].pop();
                
                if (expandedTrack === channel) {
                    renderInlinePianoRoll(channel);
                } else {
                    visualizeTrack(channel, convertedTracks[channel]);
                }
                
                updateStatus(`‚Ü∑ Redo on ${channel.toUpperCase()}`);
            } else {
                updateStatus(`No more redo history for ${channel.toUpperCase()}`);
            }
        }

        // Song length controls
        songLengthInput.addEventListener('input', (e) => {
            songLength = parseFloat(e.target.value);
            songLengthDisplay.textContent = `${songLength.toFixed(1)}s`;
            
            // Auto-adjust zoom to fit the new song length
            const minZoom = getMinZoomLevel();
            zoomLevel = minZoom;
            pixelsPerSecond = (zoomLevel / 100) * 50;
            updateZoomDisplay();
            
            // Update all track durations
            Object.keys(convertedTracks).forEach(channel => {
                if (convertedTracks[channel]) {
                    convertedTracks[channel].duration = songLength;
                    visualizeTrack(channel, convertedTracks[channel]);
                }
            });
            
            // Re-render piano roll if expanded
            if (expandedTrack) {
                renderInlinePianoRoll(expandedTrack);
            }
            
            updateStatus(`Song length set to ${songLength}s`);
        });
        
        // Allow Enter key to apply song length changes
        songLengthInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.target.blur(); // Remove focus to apply changes
            }
        });

        // Initialize song length display
        songLengthDisplay.textContent = `${songLength.toFixed(1)}s`;

        function updateStatus(message) {
            statusBar.innerHTML = message;
        }

        // Note selection state - now supports multiple notes
        let selectedNotes = new Set(); // Set of note objects
        let selectedChannel = null;

        // Clipboard for copy/paste
        let clipboard = null;
        
        // Focused track for paste operations
        let focusedTrack = null;
        
        // Function to focus a track
        function focusTrack(channel) {
            // Remove focus from all tracks
            document.querySelectorAll('.track').forEach(t => t.classList.remove('focused'));
            
            // Focus the selected track
            focusedTrack = channel;
            const track = document.querySelector(`.track-header[data-channel="${channel}"]`)?.closest('.track');
            if (track) {
                track.classList.add('focused');
            }
        }

        // Update zoom display
        function updateZoomDisplay() {
            if (zoomDisplay) {
                // Display zoom as half the internal value (200% internal = 100% displayed)
                const displayZoom = Math.round(zoomLevel / 2); // Round to whole number
                zoomDisplay.textContent = `Zoom: ${displayZoom}%`;
            }
        }

        // Keyboard shortcuts - SINGLE HANDLER FOR ALL KEYS
        document.addEventListener('keydown', (e) => {
            console.log('KEYDOWN EVENT FIRED! Key:', e.key, 'Target:', e.target.tagName);
            
            // Don't handle keys if typing in an input
            if (['INPUT', 'TEXTAREA'].includes(e.target.tagName)) return;
            
            // Spacebar - Toggle MIDI recording (if any channels are armed) OR play/stop
            if (e.key === ' ') {
                e.preventDefault();
                
                if (recordArmedChannels.size > 0) {
                    // MIDI recording mode
                    if (!isMidiRecording) {
                        // Start recording
                        isMidiRecording = true;
                        midiRecordStartTime = audioContext.currentTime;
                        midiActiveNotes.clear();
                        
                        const armedList = Array.from(recordArmedChannels).map(c => c.toUpperCase()).join(', ');
                        updateStatus(`üéπ Recording MIDI to ${armedList}...`);
                        
                        // Start playback if not already playing
                        if (!isPlaying) {
                            startPlayback();
                        }
                    } else {
                        // Stop recording and stop playback
                        isMidiRecording = false;
                        midiActiveNotes.clear();
                        
                        if (isPlaying) {
                            stopPlayback();
                        }
                        
                        updateStatus('üéπ MIDI recording stopped');
                    }
                } else {
                    // No armed channels - play/stop (restarts from beginning)
                    if (!isPlaying) {
                        startPlayback();
                    } else {
                        stopPlayback();
                    }
                }
                return;
            }
            
            // Number keys 1-9 to switch drawing instrument OR change selected notes' instrument
            if (e.key >= '1' && e.key <= '9') {
                const instId = parseInt(e.key);
                const inst = instruments.find(i => i.id === instId);
                
                if (!inst) {
                    updateStatus(`‚ö†Ô∏è Instrument ${instId} does not exist`);
                    return;
                }
                
                // If notes are selected, change their instrument
                if (selectedNotes.size > 0 && selectedChannel !== null) {
                    saveUndoState(selectedChannel);
                    
                    selectedNotes.forEach(note => {
                        note.instrument = instId;
                    });
                    
                    // Re-render the track
                    if (expandedTrack === selectedChannel) {
                        renderInlinePianoRoll(selectedChannel);
                    } else {
                        visualizeTrack(selectedChannel, convertedTracks[selectedChannel]);
                    }
                    
                    updateStatus(`üéπ Changed ${selectedNotes.size} note(s) to instrument ${instId}: ${inst.name}`);
                } else {
                    // No notes selected - just switch drawing instrument
                    currentDrawingInstrument = instId;
                    updateStatus(`üéπ Drawing with instrument ${instId}: ${inst.name}`);
                }
                return;
            }
            
            // Zoom with +/- keys
            if (e.key === '+' || e.key === '=') {
                e.preventDefault();
                const currentDisplayZoom = zoomLevel / 2;
                
                // Determine zoom step based on current zoom level (same as zoom out)
                let zoomStep;
                if (currentDisplayZoom < 10) {
                    zoomStep = 2; // 1% steps (2 internal) below 10%
                } else if (currentDisplayZoom < 25) {
                    zoomStep = 10; // 5% steps (10 internal) from 10% to 25%
                } else {
                    zoomStep = 50; // 25% steps (50 internal) above 25%
                }
                
                zoomLevel = Math.min(800, zoomLevel + zoomStep); // Max 400% displayed (800 internal)
                pixelsPerSecond = (zoomLevel / 100) * 50;
                updateZoomDisplay();
                
                // Re-render all tracks
                Object.keys(convertedTracks).forEach(channel => {
                    if (expandedTrack === channel) {
                        renderInlinePianoRoll(channel);
                    } else {
                        visualizeTrack(channel, convertedTracks[channel]);
                    }
                });
                
                updateStatus(`Zoomed in to ${Math.round(zoomLevel / 2)}%`);
                return;
            }
            
            if (e.key === '-' || e.key === '_') {
                e.preventDefault();
                const minZoom = getMinZoomLevel();
                const currentDisplayZoom = zoomLevel / 2;
                
                // Calculate what the next zoom level would be with each step size
                const nextWith25Step = zoomLevel - 50; // 25% step
                const nextWith5Step = zoomLevel - 10;  // 5% step
                const nextWith1Step = zoomLevel - 2;   // 1% step
                
                // Choose step size based on where we are AND where we'd land
                let zoomStep;
                if (currentDisplayZoom > 25 && (nextWith25Step / 2) >= 25) {
                    // Above 25% and would stay above 25%
                    zoomStep = 50;
                } else if (currentDisplayZoom > 10 && (nextWith5Step / 2) >= 10) {
                    // Above 10% and would stay above 10%
                    zoomStep = 10;
                } else {
                    // Below 10% or would cross into single digits
                    zoomStep = 2;
                }
                
                // Calculate new zoom level
                let newZoomLevel = zoomLevel - zoomStep;
                
                // Only snap to minimum if we'd go below it
                if (newZoomLevel < minZoom) {
                    newZoomLevel = minZoom;
                }
                
                zoomLevel = newZoomLevel;
                pixelsPerSecond = (zoomLevel / 100) * 50;
                updateZoomDisplay();
                
                // Re-render all tracks
                Object.keys(convertedTracks).forEach(channel => {
                    if (expandedTrack === channel) {
                        renderInlinePianoRoll(channel);
                    } else {
                        visualizeTrack(channel, convertedTracks[channel]);
                    }
                });
                
                updateStatus(`Zoomed out to ${Math.round(zoomLevel / 2)}%`);
                return;
            }
            
            // Spacebar - Play/Stop
            if (e.code === 'Space') {
                e.preventDefault();
                if (isPlaying) {
                    stopPlayback();
                } else {
                    startPlayback();
                }
                return;
            }
            
            // Delete/Backspace - delete selected notes
            if (e.key === 'Delete' || e.key === 'Backspace') {
                console.log('Delete key pressed! selectedNotes.size:', selectedNotes.size, 'selectedChannel:', selectedChannel);
            }
            if ((e.key === 'Delete' || e.key === 'Backspace') && selectedNotes.size > 0 && selectedChannel !== null) {
                console.log('Delete conditions met, calling deleteSelectedNotes()');
                e.preventDefault();
                deleteSelectedNotes();
            }
            
            // Ctrl/Cmd + Z - Undo
            if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey && selectedChannel !== null) {
                e.preventDefault();
                undo(selectedChannel);
            }
            
            // Ctrl/Cmd + Shift + Z - Redo
            if ((e.ctrlKey || e.metaKey) && e.key === 'z' && e.shiftKey && selectedChannel !== null) {
                e.preventDefault();
                redo(selectedChannel);
            }
            
            // Ctrl/Cmd + C - Copy
            if ((e.ctrlKey || e.metaKey) && e.key === 'c' && selectedNotes.size > 0) {
                e.preventDefault();
                clipboard = Array.from(selectedNotes).map(note => JSON.parse(JSON.stringify(note)));
                updateStatus(`üìã Copied ${selectedNotes.size} note(s)`);
            }
            
            // Ctrl/Cmd + V - Paste
            if ((e.ctrlKey || e.metaKey) && e.key === 'v') {
                console.log('V key pressed with Ctrl/Cmd');
                console.log('  clipboard:', clipboard);
                console.log('  clipboard length:', clipboard?.length);
                console.log('  focusedTrack:', focusedTrack);
                
                if (clipboard && clipboard.length > 0 && focusedTrack !== null) {
                    e.preventDefault();
                    
                    console.log('Paste: focusedTrack =', focusedTrack);
                    console.log('Paste: selectedChannel =', selectedChannel);
                    console.log('Paste: clipboard has', clipboard.length, 'notes');
                    console.log('Paste: target track before paste has', convertedTracks[focusedTrack]?.notes?.length || 0, 'notes');
                    
                    // Clear selection from the old track
                    selectedNotes.clear();
                    
                    // Save undo state for the target track
                    saveUndoState(focusedTrack);
                    
                    // Update selected channel to the paste target
                    selectedChannel = focusedTrack;
                    
                    // Create new notes in the focused track
                    const targetTrack = convertedTracks[focusedTrack];
                    if (!targetTrack.notes) targetTrack.notes = [];
                    
                    // Paste notes at their original time positions
                    const newNotes = [];
                    clipboard.forEach(copiedNote => {
                        const newNote = JSON.parse(JSON.stringify(copiedNote));
                        targetTrack.notes.push(newNote);
                        newNotes.push(newNote);
                    });
                    
                    // Select the newly pasted notes
                    newNotes.forEach(note => selectedNotes.add(note));
                    
                    console.log('Paste: target track after paste has', targetTrack.notes.length, 'notes');
                    
                    // Re-render the target track
                    if (expandedTrack === focusedTrack) {
                        renderInlinePianoRoll(focusedTrack);
                    } else {
                        visualizeTrack(focusedTrack, targetTrack);
                    }
                    
                    // Update timeline
                    if (window.renderTimelineNotes) {
                        window.renderTimelineNotes();
                    }
                    
                    saveProject();
                    updateStatus(`üìã Pasted ${clipboard.length} note(s) to ${focusedTrack.toUpperCase()}`);
                } else {
                    console.log('Paste conditions not met!');
                }
            }
            
            // Number keys 1-9 - Assign instrument to selected notes
            if (/^[0-9]$/.test(e.key) && selectedNotes.size > 0 && selectedChannel !== null) {
                const instIndex = parseInt(e.key);
                if (instIndex < instruments.length) {
                    const instrument = instruments[instIndex];
                    saveUndoState(selectedChannel);
                    selectedNotes.forEach(note => {
                        note.instrument = instrument.id;
                    });
                    
                    // Re-render to show color changes
                    if (expandedTrack === selectedChannel) {
                        renderInlinePianoRoll(selectedChannel);
                    } else {
                        visualizeTrack(selectedChannel, convertedTracks[selectedChannel]);
                    }
                    
                    updateStatus(`üé∏ Assigned ${selectedNotes.size} note(s) to instrument: ${instrument.name}`);
                } else {
                    updateStatus(`‚ö†Ô∏è Instrument ${instIndex} does not exist`);
                }
            }
            
            // S key - Add slide between consecutive selected notes
            if (e.key === 's' && selectedNotes.size > 1 && selectedChannel !== null) {
                e.preventDefault();
                console.log('S key pressed - adding slides to', selectedNotes.size, 'notes');
                saveUndoState(selectedChannel);
                
                // Sort selected notes by time
                const sortedNotes = Array.from(selectedNotes).sort((a, b) => a.time - b.time);
                console.log('Sorted notes:', sortedNotes.map(n => `${n.time.toFixed(2)}s`));
                
                // Get all notes in the track for checking
                const allNotes = convertedTracks[selectedChannel].notes;
                
                // Mark consecutive notes with slide
                let slideCount = 0;
                for (let i = 0; i < sortedNotes.length - 1; i++) {
                    const currentNote = sortedNotes[i];
                    const nextNote = sortedNotes[i + 1];
                    
                    console.log(`\nChecking slide ${i}: ${frequencyToNoteName(currentNote.frequency)} @ ${currentNote.time.toFixed(2)}s ‚Üí ${frequencyToNoteName(nextNote.frequency)} @ ${nextNote.time.toFixed(2)}s`);
                    
                    // Check if there are any notes between current and next
                    const currentEnd = currentNote.time + currentNote.duration;
                    const nextStart = nextNote.time;
                    
                    const notesInBetween = allNotes.filter(note => 
                        note !== currentNote && 
                        note !== nextNote && 
                        note.time >= currentEnd && 
                        note.time < nextStart
                    );
                    
                    if (notesInBetween.length > 0) {
                        console.log(`‚ùå Cannot slide: ${notesInBetween.length} note(s) exist between ${currentNote.time.toFixed(2)}s and ${nextNote.time.toFixed(2)}s`);
                        notesInBetween.forEach(n => {
                            console.log(`   - ${frequencyToNoteName(n.frequency)} @ ${n.time.toFixed(2)}s`);
                        });
                        continue;
                    }
                    
                    // No gap check - allow slides of any distance
                    const gap = nextNote.time - currentEnd;
                    console.log(`Gap: ${gap.toFixed(3)}s (no limit)`);
                    
                    // Store the target note's frequency so we know exactly which note to slide to
                    currentNote.slideToNext = true;
                    currentNote.slideTargetFreq = nextNote.frequency;
                    currentNote.slideTargetTime = nextNote.time;
                    slideCount++;
                    console.log(`‚úÖ Added slide from ${frequencyToNoteName(currentNote.frequency)} @ ${currentNote.time.toFixed(2)}s to ${frequencyToNoteName(nextNote.frequency)} @ ${nextNote.time.toFixed(2)}s`);
                }
                
                // Re-render to show slide indicators
                if (expandedTrack === selectedChannel) {
                    renderInlinePianoRoll(selectedChannel);
                } else {
                    visualizeTrack(selectedChannel, convertedTracks[selectedChannel]);
                }
                
                updateStatus(`üéµ Added ${slideCount} slide(s) between notes`);
            }
            
            // X key - Remove slides from selected notes
            if (e.key === 'x' && selectedNotes.size > 0 && selectedChannel !== null) {
                e.preventDefault();
                saveUndoState(selectedChannel);
                
                let removeCount = 0;
                
                // Get track notes for checking slide targets
                const trackNotes = convertedTracks[selectedChannel].notes;
                
                selectedNotes.forEach(note => {
                    if (note.slideToNext) {
                        // Find the target note of this slide
                        const noteIndex = trackNotes.indexOf(note);
                        const targetNote = trackNotes[noteIndex + 1];
                        
                        // Only remove slide if target note is also selected
                        // This prevents removing slides to unselected notes
                        if (targetNote && selectedNotes.has(targetNote)) {
                            note.slideToNext = false;
                            delete note.slideTargetFreq;
                            delete note.slideTargetTime;
                            removeCount++;
                        }
                    }
                });
                
                // Re-render
                if (expandedTrack === selectedChannel) {
                    renderInlinePianoRoll(selectedChannel);
                } else {
                    visualizeTrack(selectedChannel, convertedTracks[selectedChannel]);
                }
                
                updateStatus(`‚úÇÔ∏è Removed ${removeCount} slide(s)`);
            }
            
            // Ctrl/Cmd + X - Cut
            if ((e.ctrlKey || e.metaKey) && e.key === 'x' && selectedNotes.size > 0 && selectedChannel !== null) {
                e.preventDefault();
                clipboard = Array.from(selectedNotes).map(note => JSON.parse(JSON.stringify(note)));
                deleteSelectedNotes();
                updateStatus(`‚úÇÔ∏è Cut ${clipboard.length} note(s)`);
            }
            
            // Ctrl/Cmd + D - Duplicate
            if ((e.ctrlKey || e.metaKey) && e.key === 'd' && selectedNotes.size > 0 && selectedChannel !== null) {
                e.preventDefault();
                duplicateNotes();
            }
            
            // Ctrl/Cmd + A - Select all notes in current channel
            if ((e.ctrlKey || e.metaKey) && e.key === 'a' && selectedChannel !== null) {
                e.preventDefault();
                selectAllNotes();
            }
            
            // Escape - Deselect
            if (e.key === 'Escape') {
                deselectNotes();
            }
            
            // Arrow keys - move/adjust notes
            if (selectedNotes.size > 0 && selectedChannel !== null) {
                const shiftAmount = e.shiftKey ? 0.01 : 0.1; // Fine control with Shift
                
                if (e.key === 'ArrowLeft') {
                    e.preventDefault();
                    moveNotesInTime(selectedChannel, -shiftAmount);
                } else if (e.key === 'ArrowRight') {
                    e.preventDefault();
                    moveNotesInTime(selectedChannel, shiftAmount);
                } else if (e.key === 'ArrowUp') {
                    e.preventDefault();
                    changeNotesPitch(selectedChannel, 1);
                } else if (e.key === 'ArrowDown') {
                    e.preventDefault();
                    changeNotesPitch(selectedChannel, -1);
                }
            }
        });

        function deleteSelectedNotes() {
            console.log('deleteSelectedNotes called, selectedNotes.size:', selectedNotes.size, 'selectedChannel:', selectedChannel);
            if (selectedNotes.size > 0 && selectedChannel !== null) {
                const track = convertedTracks[selectedChannel];
                console.log('BEFORE delete - track has', track.notes.length, 'notes');
                
                saveUndoState(selectedChannel);
                console.log('Saved undo state with', track.notes.length, 'notes');
                
                // Create array of notes to delete to avoid modifying Set during iteration
                const notesToDelete = Array.from(selectedNotes);
                
                notesToDelete.forEach(note => {
                    const index = track.notes.indexOf(note);
                    if (index > -1) {
                        track.notes.splice(index, 1);
                        console.log('Deleted note at index', index);
                    }
                });
                
                console.log('AFTER delete - track has', track.notes.length, 'notes');
                
                const count = notesToDelete.length;
                
                // IMPORTANT: Clear selection after delete to avoid stale references
                selectedNotes.clear();
                
                if (expandedTrack === selectedChannel) {
                    renderInlinePianoRoll(selectedChannel);
                } else {
                    visualizeTrack(selectedChannel, track);
                }
                
                updateStatus(`‚úó Deleted ${count} note(s) from ${selectedChannel.toUpperCase()}`);
            }
        }

        function selectAllNotes() {
            if (selectedChannel !== null) {
                const track = convertedTracks[selectedChannel];
                if (track && track.notes) {
                    selectedNotes.clear();
                    track.notes.forEach(note => selectedNotes.add(note));
                    
                    if (expandedTrack === selectedChannel) {
                        renderInlinePianoRoll(selectedChannel);
                    } else {
                        visualizeTrack(selectedChannel, track);
                    }
                    
                    updateStatus(`Selected all ${selectedNotes.size} notes in ${selectedChannel.toUpperCase()}`);
                }
            }
        }

        function deselectNotes() {
            if (selectedNotes.size > 0) {
                const prevChannel = selectedChannel;
                selectedNotes.clear();
                selectedChannel = null;
                
                // Re-render to remove selection highlight
                Object.keys(convertedTracks).forEach(channel => {
                    if (convertedTracks[channel]) {
                        if (expandedTrack === channel) {
                            renderInlinePianoRoll(channel);
                        } else {
                            visualizeTrack(channel, convertedTracks[channel]);
                        }
                    }
                });
            }
        }

        function pasteNotes() {
            if (clipboard && selectedChannel) {
                saveUndoState(selectedChannel);
                
                // Find the earliest time in clipboard to use as reference
                const minTime = Math.min(...clipboard.map(n => n.time));
                
                clipboard.forEach(note => {
                    const newNote = JSON.parse(JSON.stringify(note));
                    // Offset by 0.5s from original position
                    newNote.time = newNote.time - minTime + 0.5;
                    if (newNote.time < songLength) {
                        convertedTracks[selectedChannel].notes.push(newNote);
                    }
                });
                
                if (expandedTrack === selectedChannel) {
                    renderInlinePianoRoll(selectedChannel);
                } else {
                    visualizeTrack(selectedChannel, convertedTracks[selectedChannel]);
                }
                
                updateStatus(`üìã Pasted ${clipboard.length} note(s) to ${selectedChannel.toUpperCase()}`);
            }
        }

        function duplicateNotes() {
            if (selectedNotes.size > 0 && selectedChannel) {
                saveUndoState(selectedChannel);
                
                const notesToDuplicate = Array.from(selectedNotes);
                const minTime = Math.min(...notesToDuplicate.map(n => n.time));
                const maxTime = Math.max(...notesToDuplicate.map(n => n.time + n.duration));
                const offset = maxTime - minTime;
                
                const newNotes = [];
                notesToDuplicate.forEach(note => {
                    const newNote = JSON.parse(JSON.stringify(note));
                    newNote.time += offset;
                    if (newNote.time < songLength) {
                        convertedTracks[selectedChannel].notes.push(newNote);
                        newNotes.push(newNote);
                    }
                });
                
                // Select the newly duplicated notes so you can keep duplicating
                selectedNotes.clear();
                newNotes.forEach(note => selectedNotes.add(note));
                
                if (expandedTrack === selectedChannel) {
                    renderInlinePianoRoll(selectedChannel);
                } else {
                    visualizeTrack(selectedChannel, convertedTracks[selectedChannel]);
                }
                
                updateStatus(`‚éò Duplicated ${newNotes.length} note(s) in ${selectedChannel.toUpperCase()}`);
            }
        }

        function moveNotesInTime(channel, deltaSeconds) {
            if (selectedNotes.size === 0) return;
            
            saveUndoState(channel);
            selectedNotes.forEach(note => {
                note.time = Math.max(0, Math.min(songLength - (note.duration || 0.25), note.time + deltaSeconds));
            });
            
            if (expandedTrack === channel) {
                renderInlinePianoRoll(channel);
            } else {
                visualizeTrack(channel, convertedTracks[channel]);
            }
        }

        function changeNotesPitch(channel, semitones) {
            if (selectedNotes.size === 0) return;
            
            saveUndoState(channel);
            
            console.log(`=== Moving ${selectedNotes.size} notes by ${semitones} steps ===`);
            
            // Just shift each note's frequency by moving the same number of steps in the array
            // This keeps the visual spacing the same
            selectedNotes.forEach((note, idx) => {
                // Find current frequency index
                let currentIdx = 0;
                let minDiff = Math.abs(note.frequency - NES_FREQUENCIES[0]);
                for (let i = 1; i < NES_FREQUENCIES.length; i++) {
                    const diff = Math.abs(note.frequency - NES_FREQUENCIES[i]);
                    if (diff < minDiff) {
                        minDiff = diff;
                        currentIdx = i;
                    }
                }
                
                // Move by the same number of steps in the frequency array
                const newIdx = currentIdx + semitones;
                
                console.log(`Note ${idx}: index ${currentIdx} ‚Üí ${newIdx} (freq ${note.frequency.toFixed(2)} ‚Üí ${newIdx >= 0 && newIdx < NES_FREQUENCIES.length ? NES_FREQUENCIES[newIdx].toFixed(2) : 'OUT OF RANGE'})`);
                
                // Only update if within valid range
                if (newIdx >= 0 && newIdx < NES_FREQUENCIES.length) {
                    note.frequency = NES_FREQUENCIES[newIdx];
                }
            });
            
            if (expandedTrack === channel) {
                renderInlinePianoRoll(channel);
            } else {
                visualizeTrack(channel, convertedTracks[channel]);
            }
            
            updateStatus(`‚ô™ Pitch changed for ${selectedNotes.size} note(s)`);
        }

        function handleNoteOverlap(channel, modifiedNote, excludeNotes = []) {
            const track = convertedTracks[channel];
            if (!track || !track.notes) return;
            
            console.log('handleNoteOverlap called for channel', channel, 'track has', track.notes.length, 'notes');
            
            const noteStart = modifiedNote.time;
            const noteEnd = modifiedNote.time + modifiedNote.duration;
            
            // Find all notes that overlap with the modified note (excluding itself AND other notes in the drag group)
            const overlappingNotes = track.notes.filter(note => {
                if (note === modifiedNote) return false;
                
                // Skip notes that are part of the same drag operation
                if (excludeNotes.includes(note)) return false;
                
                const otherStart = note.time;
                const otherEnd = note.time + note.duration;
                
                // Check if they overlap
                return (noteStart < otherEnd && noteEnd > otherStart);
            });
            
            console.log('Found', overlappingNotes.length, 'overlapping notes to process');
            
            // Remove or trim overlapping notes
            overlappingNotes.forEach(note => {
                const otherStart = note.time;
                const otherEnd = note.time + note.duration;
                
                // If modified note completely covers the other note, remove it
                if (noteStart <= otherStart && noteEnd >= otherEnd) {
                    const index = track.notes.indexOf(note);
                    if (index > -1) {
                        console.log('OVERLAP HANDLER REMOVING NOTE at index', index, 'time:', note.time, 'freq:', note.frequency);
                        track.notes.splice(index, 1);
                    }
                }
                // If other note starts before modified note, trim its end
                else if (otherStart < noteStart && otherEnd > noteStart) {
                    console.log('OVERLAP HANDLER TRIMMING END of note at', note.time);
                    note.duration = noteStart - otherStart;
                }
                // If other note ends after modified note, trim its start
                else if (otherStart < noteEnd && otherEnd > noteEnd) {
                    console.log('OVERLAP HANDLER TRIMMING START of note at', note.time);
                    const trimAmount = noteEnd - otherStart;
                    note.time = noteEnd;
                    note.duration -= trimAmount;
                }
            });
            
            console.log('After overlap handling, track has', track.notes.length, 'notes');
        }

        function selectNote(note, channel, addToSelection = false) {
            if (!addToSelection) {
                selectedNotes.clear();
            }
            
            selectedNotes.add(note);
            selectedChannel = channel;
            
            // Re-render to update selection
            if (expandedTrack === channel) {
                renderInlinePianoRoll(channel);
            } else {
                visualizeTrack(channel, convertedTracks[channel]);
            }
        }

        function changePitch(channel, note, semitones) {
            saveUndoState(channel);
            // Find current frequency index
            let currentIdx = 0;
            let minDiff = Math.abs(note.frequency - NES_FREQUENCIES[0]);
            for (let i = 1; i < NES_FREQUENCIES.length; i++) {
                const diff = Math.abs(note.frequency - NES_FREQUENCIES[i]);
                if (diff < minDiff) {
                    minDiff = diff;
                    currentIdx = i;
                }
            }
            
            // Move by semitones
            const newIdx = Math.max(0, Math.min(NES_FREQUENCIES.length - 1, currentIdx + semitones));
            note.frequency = NES_FREQUENCIES[newIdx];
            
            // Re-render if in piano roll mode
            if (expandedTrack === channel) {
                renderInlinePianoRoll(channel);
            } else {
                visualizeTrack(channel, convertedTracks[channel]);
            }
            
            updateStatus(`‚ô™ Pitch changed to ${frequencyToNoteName(note.frequency)}`);
            
            // Play preview
            playNotePreview(channel, note.frequency, 0.15);
        }

        function renderInlinePianoRoll(channel) {
            console.log('>>> renderInlinePianoRoll called for', channel, 'with', convertedTracks[channel]?.notes?.length, 'notes');
            
            const pianoKeys = document.getElementById(`${channel}PianoKeys`);
            const pianoGrid = document.getElementById(`${channel}PianoGrid`);
            const instrumentBar = document.getElementById(`${channel}InstrumentBar`);
            
            pianoKeys.innerHTML = '';
            pianoGrid.innerHTML = '';
            
            // Render instrument reference bar
            if (instrumentBar) {
                instrumentBar.style.display = 'block';
                instrumentBar.innerHTML = '';
                
                instruments.forEach(inst => {
                    const instChip = document.createElement('div');
                    instChip.style.cssText = `
                        display: inline-block;
                        padding: 2px 8px;
                        margin-right: 6px;
                        background: ${inst.color};
                        color: #1a1a2e;
                        border-radius: 3px;
                        font-size: 0.65rem;
                        font-weight: bold;
                        cursor: pointer;
                        border: 1px solid ${inst.color};
                    `;
                    instChip.textContent = `${inst.id}: ${inst.name}`;
                    instChip.title = `Press ${inst.id} to assign to selected notes`;
                    
                    // Click to select instrument for editing
                    instChip.addEventListener('click', () => {
                        selectInstrumentForEditing(inst.id);
                    });
                    
                    instrumentBar.appendChild(instChip);
                });
            }
            
            // Match the simple view exactly:
            // Simple view: total width = playableWidth + 62px (for visual piano bar)
            // Piano roll: grid width should be playableWidth, piano keys = 62px
            // Total = 62px (keys) + playableWidth (grid) = same as simple!
            const playableWidth = songLength * pixelsPerSecond;
            
            // Create piano keys and grid rows (in reverse order - highest note at top)
            for (let i = NES_FREQUENCIES.length - 1; i >= 0; i--) {
                const freq = NES_FREQUENCIES[i];
                const noteName = frequencyToNoteName(freq);
                
                // Piano key
                const key = document.createElement('div');
                key.className = 'inline-piano-key';
                
                // Check if it's a black key (has # in the name)
                if (noteName.includes('#')) {
                    key.classList.add('black-key');
                }
                
                key.textContent = noteName;
                key.dataset.frequency = freq;
                pianoKeys.appendChild(key);
                
                // Grid row - this is the scrollable area
                const row = document.createElement('div');
                row.className = 'inline-piano-grid-row';
                row.dataset.frequency = freq;
                row.dataset.freqIndex = i;
                row.dataset.rowIndex = NES_FREQUENCIES.length - 1 - i;
                // Grid width should match simple view playable width exactly
                row.style.width = `${playableWidth}px`;
                row.style.minWidth = `${playableWidth}px`;
                row.style.maxWidth = `${playableWidth}px`; // Prevent extending past song end
                
                // Click to add note
                row.addEventListener('click', (e) => {
                    console.log('Row clicked, target:', e.target.className, 'row:', row.className);
                    if (e.target === row) {
                        const rect = row.getBoundingClientRect();
                        const gridRect = pianoGrid.getBoundingClientRect();
                        const x = e.clientX - gridRect.left + pianoGrid.scrollLeft;
                        let time = x / pixelsPerSecond; // Convert pixels to seconds
                        time = snapToGrid(time); // Snap to quantization grid
                        const duration = getQuantizedNoteDuration(); // Use quantized duration
                        console.log('Adding note at time:', time, 'duration:', duration, 'freq:', freq);
                        addInlinePianoNote(channel, freq, time, duration);
                    }
                });
                
                pianoGrid.appendChild(row);
            }
            
            // Sync scroll positions of keys and grid
            pianoGrid.addEventListener('scroll', () => {
                pianoKeys.scrollTop = pianoGrid.scrollTop;
            });
            
            pianoKeys.addEventListener('scroll', () => {
                pianoGrid.scrollTop = pianoKeys.scrollTop;
            });
            
            // Add vertical grid lines aligned to quantization
            // First, remove any existing grid lines
            const existingGridLines = pianoGrid.querySelector('.grid-lines-container');
            if (existingGridLines) {
                existingGridLines.remove();
            }
            
            const gridLinesContainer = document.createElement('div');
            gridLinesContainer.className = 'grid-lines-container';
            gridLinesContainer.style.position = 'absolute';
            gridLinesContainer.style.top = '0';
            gridLinesContainer.style.left = '0';
            gridLinesContainer.style.width = `${playableWidth}px`;
            gridLinesContainer.style.height = `${NES_FREQUENCIES.length * 20}px`;
            gridLinesContainer.style.pointerEvents = 'none';
            gridLinesContainer.style.zIndex = '0';
            
            // Use reference BPM (120) since notes are stored at reference timing
            const referenceBPM = 120;
            const beatTime = 60 / referenceBPM; // 0.5s per beat at 120 BPM
            const measureTime = beatTime * timeSignature; // seconds per measure
            
            // Get current quantization setting
            const quantization = document.getElementById('noteQuantization').value;
            let subdivisionTime;
            switch (quantization) {
                case 'eighth':
                    subdivisionTime = beatTime / 2; // 8th notes (0.25s)
                    break;
                case 'sixteenth':
                    subdivisionTime = beatTime / 4; // 16th notes (0.125s)
                    break;
                case 'thirtysecond':
                    subdivisionTime = beatTime / 8; // 32nd notes (0.0625s)
                    break;
                default:
                    subdivisionTime = beatTime / 2; // Default to 8th notes
            }
            
            for (let t = 0; t <= songLength; t += subdivisionTime) {
                const x = t * pixelsPerSecond;
                
                // Measure lines (every measure based on time signature)
                const isMeasureLine = Math.abs(t % measureTime) < 0.01;
                
                const line = document.createElement('div');
                line.style.position = 'absolute';
                line.style.left = `${x}px`;
                line.style.top = '0';
                line.style.width = isMeasureLine ? '3px' : '1px';
                line.style.height = '100%';
                line.style.background = isMeasureLine 
                    ? 'rgba(0, 255, 159, 0.15)' 
                    : 'rgba(255, 255, 255, 0.04)';
                
                gridLinesContainer.appendChild(line);
            }
            
            pianoGrid.insertBefore(gridLinesContainer, pianoGrid.firstChild);
            
            // Scroll to middle C (C4) on first open only
            if (!hasAutoScrolled[channel]) {
                // C4 is at index 24 in NES_FREQUENCIES (octave 2 starts at 0, so C4 = 2*12)
                // It appears from the bottom since we render in reverse, so it's at row index (60 - 24 - 1)
                const middleCRowIndex = NES_FREQUENCIES.length - 1 - 24;
                const middleCRow = pianoGrid.children[middleCRowIndex];
                if (middleCRow) {
                    // Scroll so middle C is roughly centered (subtract half the visible height)
                    const scrollTarget = middleCRow.offsetTop - 160 + 10; // 160px = half of 320px visible area
                    pianoGrid.scrollTop = Math.max(0, scrollTarget);
                    pianoKeys.scrollTop = pianoGrid.scrollTop;
                }
                hasAutoScrolled[channel] = true;
            }
            
            // Render existing notes - make sure to sort by frequency to match rows
            const track = convertedTracks[channel];
            if (track && track.notes && track.notes.length > 0) {
                console.log(`Rendering ${track.notes.length} notes for ${channel}`);
                track.notes.forEach((note, idx) => {
                    createInlinePianoNoteElement(channel, note, idx);
                });
            } else {
                console.log(`No notes to render for ${channel}`);
            }
            
            // Update timeline visualization
            if (window.renderTimelineNotes) window.renderTimelineNotes();
        }

        function addInlinePianoNote(channel, frequency, time, duration) {
            saveUndoState(channel);
            
            const note = {
                frequency: frequency,
                time: time,
                duration: duration,
                velocity: 0.8,
                instrument: currentDrawingInstrument
            };
            
            convertedTracks[channel].notes.push(note);
            handleNoteOverlap(channel, note);
            renderInlinePianoRoll(channel);
            if (window.renderTimelineNotes) window.renderTimelineNotes();
            updateStatus(`‚ô™ Added ${frequencyToNoteName(frequency)} at ${time.toFixed(2)}s`);
            
            // Play preview with current instrument
            playNotePreview(channel, frequency, 0.2, note.instrument);
        }

        function createInlinePianoNoteElement(channel, note, index) {
            const pianoGrid = document.getElementById(`${channel}PianoGrid`);
            if (!pianoGrid) {
                console.error(`Piano grid not found for channel ${channel}`);
                return;
            }
            
            // Find the row for this frequency
            const rows = pianoGrid.querySelectorAll('.inline-piano-grid-row');
            let targetRow = null;
            
            // Try exact match with small tolerance
            for (let row of rows) {
                if (Math.abs(parseFloat(row.dataset.frequency) - note.frequency) < 0.1) {
                    targetRow = row;
                    break;
                }
            }
            
            if (!targetRow) {
                // Find closest frequency
                let closestRow = null;
                let minDiff = Infinity;
                
                for (let row of rows) {
                    const diff = Math.abs(parseFloat(row.dataset.frequency) - note.frequency);
                    if (diff < minDiff) {
                        minDiff = diff;
                        closestRow = row;
                    }
                }
                targetRow = closestRow;
                console.log(`No exact match for freq ${note.frequency}, using closest: ${targetRow.dataset.frequency}`);
            }
            
            if (!targetRow) {
                console.error(`Could not find any row for frequency ${note.frequency}`);
                return;
            }
            
            console.log(`Rendering note at time=${note.time}s, freq=${note.frequency}Hz, duration=${note.duration}s`);
            
            // Get instrument for this note
            const inst = instruments.find(i => i.id === (note.instrument || 1)) || instruments[0];
            
            // Use base pixels per second (notes stored at reference timing)
            const noteEl = document.createElement('div');
            noteEl.className = 'inline-piano-note';
            noteEl.style.left = `${note.time * pixelsPerSecond}px`;
            noteEl.style.width = `${(note.duration || 0.25) * pixelsPerSecond}px`;
            noteEl.style.background = inst.color;
            noteEl.style.borderColor = inst.color;
            noteEl.style.cursor = 'move';
            noteEl.dataset.index = index;
            noteEl.dataset.noteIndex = index; // For drag-select
            
            // Check if selected
            if (selectedNotes.has(note)) {
                noteEl.classList.add('selected');
            }
            
            // Add text content directly to note
            noteEl.textContent = frequencyToNoteName(note.frequency);
            
            // Create invisible resize zones OUTSIDE the note
            const leftResizeZone = document.createElement('div');
            leftResizeZone.className = 'resize-zone-left';
            leftResizeZone.style.cssText = 'position: absolute; left: 0px; width: 5px; top: 0; bottom: 0; cursor: ew-resize; z-index: 14;';
            noteEl.appendChild(leftResizeZone);
            
            const rightResizeZone = document.createElement('div');
            rightResizeZone.className = 'resize-zone-right';
            rightResizeZone.style.cssText = 'position: absolute; right: 0px; width: 5px; top: 0; bottom: 0; cursor: ew-resize; z-index: 14;';
            noteEl.appendChild(rightResizeZone);
            
            // Update cursor - note always shows move, zones show resize
            noteEl.addEventListener('mousemove', (e) => {
                // Only update if directly over the note, not a child element
                if (e.target === noteEl) {
                    noteEl.style.cursor = 'move';
                }
            });
            
            // Reset cursor when mouse leaves
            noteEl.addEventListener('mouseleave', () => {
                noteEl.style.cursor = 'move';
            });
            
            // Click to select
            noteEl.addEventListener('click', (e) => {
                e.stopPropagation();
                const addToSelection = e.ctrlKey || e.metaKey || e.shiftKey;
                selectNote(note, channel, addToSelection);
                renderInlinePianoRoll(channel);
            });
            
            // Double-click to edit frequency
            noteEl.addEventListener('dblclick', (e) => {
                e.stopPropagation();
                const newFreq = prompt('Enter frequency (Hz):', note.frequency);
                if (newFreq && !isNaN(newFreq)) {
                    saveUndoState(channel);
                    note.frequency = parseFloat(newFreq);
                    renderInlinePianoRoll(channel);
                }
            });
            
            // Drag to move or resize
            noteEl.addEventListener('mousedown', (e) => {
                console.log('Note mousedown!', e.target.className);
                
                // Check if clicked on a resize zone
                const isLeftResize = e.target.classList.contains('resize-zone-left');
                const isRightResize = e.target.classList.contains('resize-zone-right');
                
                console.log('isLeftResize:', isLeftResize, 'isRightResize:', isRightResize);
                
                if (isRightResize || isLeftResize) {
                    // RESIZE MODE
                    e.preventDefault();
                    e.stopPropagation();
                    
                    saveUndoState(channel);
                    const startX = e.clientX;
                    const startTime = note.time;
                    const startDuration = note.duration;
                    
                    const onMouseMove = (moveEvent) => {
                        const deltaX = moveEvent.clientX - startX;
                        const deltaTime = deltaX / pixelsPerSecond;
                        
                        if (isLeftResize) {
                            // Resize from left (change time and duration)
                            let newTime = snapToGrid(startTime + deltaTime);
                            newTime = Math.max(0, Math.min(songLength - 0.1, newTime));
                            const timeDiff = newTime - startTime;
                            const newDuration = Math.max(0.1, startDuration - timeDiff);
                            
                            note.time = newTime;
                            note.duration = newDuration;
                        } else {
                            // Resize from right (change duration only)
                            // Calculate the end time and snap it
                            const rawEndTime = startTime + startDuration + deltaTime;
                            const snappedEndTime = snapToGrid(rawEndTime);
                            console.log('Right resize - rawEndTime:', rawEndTime.toFixed(3), 'snappedEndTime:', snappedEndTime.toFixed(3));
                            let newDuration = snappedEndTime - note.time;
                            newDuration = Math.max(0.1, Math.min(songLength - note.time, newDuration));
                            note.duration = newDuration;
                        }
                        
                        renderInlinePianoRoll(channel);
                    };
                    
                    const onMouseUp = () => {
                        document.removeEventListener('mousemove', onMouseMove);
                        document.removeEventListener('mouseup', onMouseUp);
                        handleNoteOverlap(channel, note);
                        renderInlinePianoRoll(channel);
                    };
                    
                    document.addEventListener('mousemove', onMouseMove);
                    document.addEventListener('mouseup', onMouseUp);
                    return;
                }
                
                // MOVE MODE (not resizing)
                console.log('Entering MOVE MODE');
                e.preventDefault();
                e.stopPropagation();
                
                // Ensure the clicked note is selected before checking duplication
                if (!selectedNotes.has(note)) {
                    // Add to selection if Cmd held, otherwise replace selection
                    if (e.ctrlKey || e.metaKey) {
                        selectedNotes.add(note);
                        selectedChannel = channel;
                    } else {
                        selectedNotes.clear();
                        selectedNotes.add(note);
                        selectedChannel = channel;
                    }
                }
                
                // Check if Ctrl/Cmd is held for duplication
                const isDuplicating = (e.ctrlKey || e.metaKey) && selectedNotes.size > 0 && selectedNotes.has(note);
                let originalNotes = null;
                let duplicateElements = new Map();
                
                if (isDuplicating) {
                    // Save undo state for duplication
                    saveUndoState(channel);
                    
                    // Store copies of the original notes
                    originalNotes = Array.from(selectedNotes).map(n => JSON.parse(JSON.stringify(n)));
                    
                    // Create duplicates
                    const duplicates = [];
                    let clickedDuplicate = null;
                    
                    selectedNotes.forEach(selectedNote => {
                        const duplicate = JSON.parse(JSON.stringify(selectedNote));
                        convertedTracks[channel].notes.push(duplicate);
                        duplicates.push(duplicate);
                        
                        if (selectedNote === note) {
                            clickedDuplicate = duplicate;
                        }
                    });
                    
                    // Clear selection and select duplicates
                    selectedNotes.clear();
                    duplicates.forEach(dup => selectedNotes.add(dup));
                    note = clickedDuplicate;
                    
                    // Re-render to show everything
                    renderInlinePianoRoll(channel);
                    
                    // Ghost the originals and collect duplicate elements
                    setTimeout(() => {
                        const allNoteElements = document.querySelectorAll(`#${channel}PianoGrid .inline-piano-note`);
                        const track = convertedTracks[channel];
                        
                        allNoteElements.forEach(el => {
                            const idx = parseInt(el.dataset.noteIndex);
                            const noteObj = track.notes[idx];
                            
                            // Check if this is an original (should be ghosted)
                            const isOriginal = originalNotes.some(orig => 
                                Math.abs(orig.time - noteObj.time) < 0.01 && 
                                Math.abs(orig.frequency - noteObj.frequency) < 0.1
                            );
                            
                            if (isOriginal) {
                                el.style.opacity = '0.3';
                            }
                            
                            // Check if this is a duplicate (track its element)
                            duplicates.forEach(dup => {
                                if (Math.abs(dup.time - noteObj.time) < 0.01 && 
                                    Math.abs(dup.frequency - noteObj.frequency) < 0.1) {
                                    duplicateElements.set(dup, el);
                                }
                            });
                        });
                    }, 10);
                } else {
                    // Normal drag without duplication  
                    if (!selectedNotes.has(note)) {
                        // Add to selection without re-rendering
                        selectedNotes.clear();
                        selectedNotes.add(note);
                        selectedChannel = channel;
                    }
                    // Don't re-render during drag start - will re-render on mouseup
                }
                
                const startX = e.clientX;
                const draggedNotes = Array.from(selectedNotes);
                const startPositions = new Map();
                const noteElements = new Map(); // Track DOM elements for all selected notes
                
                draggedNotes.forEach(n => {
                    startPositions.set(n, { time: n.time, freq: n.frequency });
                });
                
                // If not duplicating, find and track DOM elements for all selected notes
                if (!isDuplicating) {
                    setTimeout(() => {
                        const allNoteElements = document.querySelectorAll(`#${channel}PianoGrid .inline-piano-note`);
                        const track = convertedTracks[channel];
                        
                        allNoteElements.forEach(el => {
                            const idx = parseInt(el.dataset.noteIndex);
                            const noteObj = track.notes[idx];
                            
                            draggedNotes.forEach(dragNote => {
                                if (Math.abs(dragNote.time - noteObj.time) < 0.01 && 
                                    Math.abs(dragNote.frequency - noteObj.frequency) < 0.1) {
                                    noteElements.set(dragNote, el);
                                }
                            });
                        });
                    }, 10);
                }
                
                let lastPreviewTime = 0;
                let lastFrequency = note.frequency;
                let undoSaved = false; // Track if we've saved undo state
                
                const onMouseMove = (moveEvent) => {
                    // Save undo state on first move
                    if (!undoSaved) {
                        saveUndoState(channel);
                        undoSaved = true;
                    }
                    
                    console.log('Mouse moving!', moveEvent.clientX, moveEvent.clientY);
                    const deltaX = moveEvent.clientX - startX;
                    const deltaTime = deltaX / pixelsPerSecond;
                    
                    console.log('deltaX:', deltaX, 'deltaTime:', deltaTime);
                    
                    if (isDuplicating) {
                        // When duplicating, only move in time, keep pitch the same
                        draggedNotes.forEach(dragNote => {
                            const origPos = startPositions.get(dragNote);
                            let newTime = snapToGrid(origPos.time + deltaTime);
                            dragNote.time = Math.max(0, Math.min(songLength - dragNote.duration, newTime));
                            
                            // Update DOM element if we have it
                            if (duplicateElements.has(dragNote)) {
                                const el = duplicateElements.get(dragNote);
                                el.style.left = `${dragNote.time * pixelsPerSecond}px`;
                            }
                        });
                    } else {
                        // Normal drag - allow pitch and time changes
                        const pianoGrid = document.getElementById(`${channel}PianoGrid`);
                        const allRows = pianoGrid.querySelectorAll('.inline-piano-grid-row');
                        const mouseY = moveEvent.clientY;
                        let bestRow = null;
                        let minDistance = Infinity;
                        
                        allRows.forEach(row => {
                            const rowRect = row.getBoundingClientRect();
                            const rowCenterY = rowRect.top + rowRect.height / 2;
                            const distance = Math.abs(mouseY - rowCenterY);
                            
                            if (distance < minDistance) {
                                minDistance = distance;
                                bestRow = row;
                            }
                        });
                        
                        if (bestRow) {
                            const targetFreq = parseFloat(bestRow.dataset.frequency);
                            const startFreq = startPositions.get(note).freq;
                            
                            // Find array indices instead of using Hz delta
                            let startIdx = 0;
                            let targetIdx = 0;
                            let minDiff1 = Math.abs(startFreq - NES_FREQUENCIES[0]);
                            let minDiff2 = Math.abs(targetFreq - NES_FREQUENCIES[0]);
                            
                            for (let i = 1; i < NES_FREQUENCIES.length; i++) {
                                const diff1 = Math.abs(startFreq - NES_FREQUENCIES[i]);
                                const diff2 = Math.abs(targetFreq - NES_FREQUENCIES[i]);
                                if (diff1 < minDiff1) {
                                    minDiff1 = diff1;
                                    startIdx = i;
                                }
                                if (diff2 < minDiff2) {
                                    minDiff2 = diff2;
                                    targetIdx = i;
                                }
                            }
                            
                            // Calculate index delta (semitone shift)
                            const indexDelta = targetIdx - startIdx;
                            
                            // Move ALL notes by the same INDEX delta
                            draggedNotes.forEach(dragNote => {
                                const origPos = startPositions.get(dragNote);
                                let rawTime = origPos.time + deltaTime;
                                let newTime = snapToGrid(rawTime);
                                
                                if (Math.abs(rawTime - newTime) > 0.001) {
                                    console.log('Snapping:', rawTime.toFixed(3), '‚Üí', newTime.toFixed(3));
                                }
                                
                                dragNote.time = Math.max(0, Math.min(songLength - dragNote.duration, newTime));
                                
                                // Find original note's index
                                let origIdx = 0;
                                let minOrigDiff = Math.abs(origPos.freq - NES_FREQUENCIES[0]);
                                for (let i = 1; i < NES_FREQUENCIES.length; i++) {
                                    const diff = Math.abs(origPos.freq - NES_FREQUENCIES[i]);
                                    if (diff < minOrigDiff) {
                                        minOrigDiff = diff;
                                        origIdx = i;
                                    }
                                }
                                
                                // Apply the same index delta
                                const newIdx = origIdx + indexDelta;
                                if (newIdx >= 0 && newIdx < NES_FREQUENCIES.length) {
                                    dragNote.frequency = NES_FREQUENCIES[newIdx];
                                }
                                
                                // Update DOM element if we have it - use SNAPPED position
                                if (noteElements.has(dragNote)) {
                                    const el = noteElements.get(dragNote);
                                    // Use the SNAPPED time, not the smooth mouse position
                                    el.style.left = `${dragNote.time * pixelsPerSecond}px`;
                                    el.textContent = frequencyToNoteName(dragNote.frequency);
                                    
                                    // Move element to the correct row visually
                                    const pianoGrid = document.getElementById(`${channel}PianoGrid`);
                                    const targetRow = Array.from(pianoGrid.querySelectorAll('.inline-piano-grid-row'))
                                        .find(row => Math.abs(parseFloat(row.dataset.frequency) - dragNote.frequency) < 0.1);
                                    
                                    if (targetRow && el.parentElement !== targetRow) {
                                        targetRow.appendChild(el);
                                    }
                                }
                            });
                            
                            // Play preview
                            if (targetFreq !== lastFrequency) {
                                const now = Date.now();
                                if (now - lastPreviewTime > 100) {
                                    playNotePreview(channel, note.frequency, 0.05);
                                    lastPreviewTime = now;
                                }
                                lastFrequency = targetFreq;
                            }
                        }
                    }
                };
                
                const onMouseUp = () => {
                    if (isDuplicating && originalNotes) {
                        // Restore originals
                        originalNotes.forEach(orig => {
                            convertedTracks[channel].notes.push(orig);
                        });
                    }
                    
                    // Handle overlaps and re-render
                    // Pass draggedNotes so they don't check against each other
                    draggedNotes.forEach(dragNote => {
                        handleNoteOverlap(channel, dragNote, draggedNotes);
                    });
                    
                    renderInlinePianoRoll(channel);
                    document.removeEventListener('mousemove', onMouseMove);
                    document.removeEventListener('mouseup', onMouseUp);
                };
                
                document.addEventListener('mousemove', onMouseMove);
                document.addEventListener('mouseup', onMouseUp);
            });
            
            targetRow.appendChild(noteEl);
            
            // Draw slide line if this note slides to the next
            if (note.slideToNext && note.slideTargetFreq && note.slideTargetTime) {
                // Find the specific target note
                const track = convertedTracks[channel];
                const nextNote = track.notes.find(n => 
                    Math.abs(n.frequency - note.slideTargetFreq) < 0.1 && 
                    Math.abs(n.time - note.slideTargetTime) < 0.01
                );
                
                if (nextNote) {
                    // Calculate positions
                    const startX = (note.time + note.duration) * pixelsPerSecond;
                    const endX = nextNote.time * pixelsPerSecond;
                    const lineWidth = endX - startX;
                    
                    // Find the row for the next note to calculate Y offset
                    let nextNoteRowOffset = 0;
                    const rows = pianoGrid.querySelectorAll('.inline-piano-grid-row');
                    let currentRowIndex = -1;
                    let nextRowIndex = -1;
                    
                    rows.forEach((row, index) => {
                        if (Math.abs(parseFloat(row.dataset.frequency) - note.frequency) < 0.1) {
                            currentRowIndex = index;
                        }
                        if (Math.abs(parseFloat(row.dataset.frequency) - nextNote.frequency) < 0.1) {
                            nextRowIndex = index;
                        }
                    });
                    
                    if (currentRowIndex >= 0 && nextRowIndex >= 0) {
                        // Calculate vertical offset (20px per row)
                        const rowHeight = 20;
                        nextNoteRowOffset = (nextRowIndex - currentRowIndex) * rowHeight;
                        
                        // Create SVG line for diagonal connection
                        const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                        svg.style.position = 'absolute';
                        svg.style.left = `${startX}px`;
                        svg.style.top = nextNoteRowOffset < 0 ? `${nextNoteRowOffset}px` : '0px';
                        svg.style.width = `${lineWidth}px`;
                        svg.style.height = `${Math.abs(nextNoteRowOffset) + 20}px`;
                        svg.style.pointerEvents = 'none';
                        svg.style.zIndex = '5';
                        svg.style.overflow = 'visible';
                        
                        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                        line.setAttribute('x1', '0');
                        line.setAttribute('y1', nextNoteRowOffset < 0 ? Math.abs(nextNoteRowOffset) + 10 : '10');
                        line.setAttribute('x2', lineWidth);
                        line.setAttribute('y2', nextNoteRowOffset < 0 ? '10' : Math.abs(nextNoteRowOffset) + 10);
                        line.setAttribute('stroke', inst.color);
                        line.setAttribute('stroke-width', '2');
                        line.setAttribute('opacity', '0.7');
                        
                        svg.appendChild(line);
                        targetRow.appendChild(svg);
                    }
                }
            }
        }

        // Timeline click to add notes (only in simple mode) and drag-select
        Object.keys(trackElements).forEach(channel => {
            const trackContent = trackElements[channel];
            
            trackContent.addEventListener('mousedown', (e) => {
                console.log('Track content mousedown, target:', e.target.className, 'piano-roll-mode:', trackContent.classList.contains('piano-roll-mode'));
                
                // Focus this track for paste operations
                focusTrack(channel);
                
                // In piano roll mode, enable drag select on piano grid background
                if (trackContent.classList.contains('piano-roll-mode')) {
                    // Only start drag-select if clicking on grid row (not on a note)
                    if (e.target.classList.contains('inline-piano-grid-row') || 
                        e.target.classList.contains('inline-piano-grid')) {
                        
                        // Don't prevent default - let click event fire for adding notes
                        // Only track that we might start dragging
                        const startPos = { x: e.clientX, y: e.clientY };
                        
                        const checkForDrag = (moveEvent) => {
                            const deltaX = Math.abs(moveEvent.clientX - startPos.x);
                            const deltaY = Math.abs(moveEvent.clientY - startPos.y);
                            
                            // If moved more than 5 pixels, start drag-select
                            if (deltaX > 5 || deltaY > 5) {
                                e.preventDefault();
                                isDragSelecting = true;
                                dragSelectChannel = channel;
                                dragSelectStart = startPos;
                                
                                if (!(e.ctrlKey || e.metaKey)) {
                                    selectedNotes.clear();
                                }
                                selectedChannel = channel;
                                console.log('Started drag select in piano roll on', channel);
                                
                                document.removeEventListener('mousemove', checkForDrag);
                            }
                        };
                        
                        const cleanupCheck = () => {
                            document.removeEventListener('mousemove', checkForDrag);
                            document.removeEventListener('mouseup', cleanupCheck);
                        };
                        
                        document.addEventListener('mousemove', checkForDrag);
                        document.addEventListener('mouseup', cleanupCheck);
                    }
                    return;
                }
                
                // Simple mode drag-select
                // Don't interfere if clicking on a note or resize handle
                if (e.target.classList.contains('note-block') || 
                    e.target.parentElement.classList.contains('note-block') ||
                    e.target.classList.contains('resize-handle')) {
                    return;
                }
                
                // Prevent text selection
                e.preventDefault();
                
                // Start drag selection in simple mode
                isDragSelecting = true;
                dragSelectChannel = channel;
                dragSelectStart = { x: e.clientX, y: e.clientY };
                userDidDrag = false; // Reset flag
                
                // Clear selection if not holding Ctrl/Cmd
                if (!(e.ctrlKey || e.metaKey)) {
                    selectedNotes.clear();
                }
                selectedChannel = channel;
                
                console.log('Started drag select on', channel);
            });
            
            trackContent.addEventListener('click', (e) => {
                console.log('Track content clicked, target:', e.target.className, 'current target:', e.currentTarget.id);
                
                // Don't deselect if user just finished dragging (drag-select or drag-move)
                if (userDidDrag) {
                    console.log('User just dragged, skipping deselection');
                    return;
                }
                
                // Check if we clicked on a note or inside a note
                let element = e.target;
                let clickedOnNote = false;
                while (element && element !== trackContent) {
                    if (element.classList.contains('note-block')) {
                        clickedOnNote = true;
                        break;
                    }
                    element = element.parentElement;
                }
                
                // If NOT clicking on a note and in collapsed view, deselect
                if (!clickedOnNote && !trackContent.classList.contains('piano-roll-mode') && selectedNotes.size > 0) {
                    selectedNotes.clear();
                    selectedChannel = null;
                    visualizeTrack(channel, convertedTracks[channel]);
                    console.log('Deselected notes - clicked on empty space');
                }
                
                // Don't create notes in collapsed view - only in piano roll mode
                // Collapsed view is for selecting/editing existing notes only
                console.log('Collapsed view - note creation disabled');
                return;
                
                /* NOTE CREATION DISABLED IN COLLAPSED VIEW
                // Don't add if user just dragged to select
                if (userDidDrag) {
                    console.log('User just dragged, skipping note creation');
                    return;
                }
                
                // Don't add if in piano roll mode
                if (trackContent.classList.contains('piano-roll-mode')) {
                    return;
                }
                
                // Don't add if clicking on a note
                if (e.target.classList.contains('note-block') || e.target.parentElement.classList.contains('note-block')) {
                    console.log('Click was on note-block, skipping');
                    return;
                }
                
                // Don't add if clicking on placeholder text
                if (e.target.classList.contains('waveform-placeholder')) {
                    return;
                }
                
                // Don't add if clicking on instrument reference bar
                if (e.target.classList.contains('instrument-reference-bar')) {
                    return;
                }
                
                const simpleContent = trackContent.querySelector('.track-simple-content');
                if (!simpleContent) return;
                
                const rect = simpleContent.getBoundingClientRect();
                const x = e.clientX - rect.left - 62; // Subtract the padding width
                
                // Don't add if clicking on the 62px instrument bar area (left side)
                if (x < 0) {
                    console.log('Click was on instrument bar area, skipping');
                    return;
                }
                
                const time = x / pixelsPerSecond; // Use current pixelsPerSecond
                
                if (time >= 0 && time <= songLength) {
                    saveUndoState(channel);
                    
                    // Default frequency (middle C)
                    const defaultFreq = 261.63;
                    
                    const note = {
                        frequency: defaultFreq,
                        time: time,
                        duration: 0.25,
                        velocity: 0.8
                    };
                    
                    convertedTracks[channel].notes.push(note);
                    handleNoteOverlap(channel, note);
                    visualizeTrack(channel, convertedTracks[channel]);
                    updateStatus(`‚ô™ Added ${frequencyToNoteName(defaultFreq)} to ${channel.toUpperCase()} at ${time.toFixed(2)}s`);
                    
                    // Play preview
                    playNotePreview(channel, defaultFreq, 0.2);
                }
                */
            });
        });

        // Global mouse handlers for drag selection
        document.addEventListener('mousemove', (e) => {
            if (!isDragSelecting) return;
            
            // Mark that user has dragged
            const dragDistance = Math.abs(e.clientX - dragSelectStart.x) + Math.abs(e.clientY - dragSelectStart.y);
            if (dragDistance > 5) { // Minimum 5px movement to count as drag
                userDidDrag = true;
            }
            
            const selectionBox = document.getElementById('selectionBox');
            const x1 = Math.min(dragSelectStart.x, e.clientX);
            const y1 = Math.min(dragSelectStart.y, e.clientY);
            const x2 = Math.max(dragSelectStart.x, e.clientX);
            const y2 = Math.max(dragSelectStart.y, e.clientY);
            
            selectionBox.style.left = `${x1}px`;
            selectionBox.style.top = `${y1}px`;
            selectionBox.style.width = `${x2 - x1}px`;
            selectionBox.style.height = `${y2 - y1}px`;
            selectionBox.style.display = 'block';
            
            console.log('Drag selecting, box size:', x2-x1, 'x', y2-y1);
            
            // Find notes within selection box
            if (dragSelectChannel) {
                const track = convertedTracks[dragSelectChannel];
                if (track && track.notes) {
                    // Check which mode we're in
                    const trackContent = trackElements[dragSelectChannel];
                    const isPianoRollMode = trackContent.classList.contains('piano-roll-mode');
                    
                    let noteElements;
                    if (isPianoRollMode) {
                        noteElements = document.querySelectorAll(`#${dragSelectChannel}PianoGrid .inline-piano-note`);
                        console.log('Piano roll mode: Found', noteElements.length, 'piano notes to check');
                    } else {
                        noteElements = document.querySelectorAll(`#${dragSelectChannel}Track .note-block`);
                        console.log('Simple mode: Found', noteElements.length, 'note blocks to check');
                    }
                    
                    // First, remove all temporary selection highlights
                    noteElements.forEach(elem => {
                        const noteIndex = parseInt(elem.dataset.noteIndex);
                        const note = track.notes[noteIndex];
                        if (note && !selectedNotes.has(note)) {
                            elem.classList.remove('selected');
                        }
                    });
                    
                    // Then add highlights to intersecting notes
                    noteElements.forEach((elem) => {
                        const rect = elem.getBoundingClientRect();
                        const blockX1 = rect.left;
                        const blockY1 = rect.top;
                        const blockX2 = rect.right;
                        const blockY2 = rect.bottom;
                        
                        // Check if note intersects with selection box
                        const intersects = !(blockX2 < x1 || blockX1 > x2 || blockY2 < y1 || blockY1 > y2);
                        
                        if (intersects) {
                            const noteIndex = parseInt(elem.dataset.noteIndex);
                            if (!isNaN(noteIndex) && track.notes[noteIndex]) {
                                elem.classList.add('selected');
                                console.log('Highlighting note:', noteIndex, 'classList now has selected:', elem.classList.contains('selected'));
                            }
                        }
                    });
                }
            }
        });
        
        document.addEventListener('mouseup', () => {
            if (isDragSelecting) {
                // Now actually add to selectedNotes Set
                if (dragSelectChannel) {
                    const track = convertedTracks[dragSelectChannel];
                    const trackContent = trackElements[dragSelectChannel];
                    const isPianoRollMode = trackContent.classList.contains('piano-roll-mode');
                    
                    if (track && track.notes) {
                        let noteElements;
                        if (isPianoRollMode) {
                            noteElements = document.querySelectorAll(`#${dragSelectChannel}PianoGrid .inline-piano-note`);
                        } else {
                            noteElements = document.querySelectorAll(`#${dragSelectChannel}Track .note-block`);
                        }
                        
                        noteElements.forEach((elem) => {
                            if (elem.classList.contains('selected')) {
                                const noteIndex = parseInt(elem.dataset.noteIndex);
                                if (!isNaN(noteIndex) && track.notes[noteIndex]) {
                                    selectedNotes.add(track.notes[noteIndex]);
                                    console.log('Added note to selection:', noteIndex);
                                }
                            }
                        });
                    }
                }
                
                console.log('Drag select ended. Selected notes:', selectedNotes.size);
                isDragSelecting = false;
                const selectionBox = document.getElementById('selectionBox');
                selectionBox.style.display = 'none';
                
                // Keep userDidDrag flag set briefly to prevent click event from firing
                setTimeout(() => {
                    userDidDrag = false;
                }, 100);
                
                // Re-render to persist selection
                if (dragSelectChannel) {
                    const trackContent = trackElements[dragSelectChannel];
                    if (trackContent.classList.contains('piano-roll-mode')) {
                        renderInlinePianoRoll(dragSelectChannel);
                    } else {
                        visualizeTrack(dragSelectChannel, convertedTracks[dragSelectChannel]);
                    }
                }
                dragSelectChannel = null;
            }
        });

        function visualizeTrack(channel, trackData) {
            const trackElement = trackElements[channel];
            
            // Check if in piano roll mode - if so, don't touch simple view
            if (trackElement.classList.contains('piano-roll-mode')) {
                return;
            }
            
            const simpleContent = trackElement.querySelector('.track-simple-content');
            if (!simpleContent) {
                console.error('simpleContent not found for', channel);
                return;
            }
            
            console.log('visualizeTrack for', channel, 'simpleContent exists:', !!simpleContent, 'track has', trackData?.notes?.length || 0, 'notes');
            
            // Clear only note blocks, not the entire content
            const existingNotes = simpleContent.querySelectorAll('.note-block');
            existingNotes.forEach(note => note.remove());
            
            // Remove or add placeholder
            let placeholder = simpleContent.querySelector('.waveform-placeholder');
            
            if (!trackData || !trackData.notes || trackData.notes.length === 0) {
                if (!placeholder) {
                    placeholder = document.createElement('div');
                    placeholder.className = 'waveform-placeholder';
                    placeholder.textContent = 'Click to add notes or expand for piano roll';
                    simpleContent.appendChild(placeholder);
                }
                return;
            } else {
                if (placeholder) {
                    placeholder.remove();
                }
            }
            
            // Use base pixels per second (notes stored at reference timing)
            const pxPerSecond = pixelsPerSecond;
            const playableWidth = songLength * pxPerSecond;
            simpleContent.style.width = `${playableWidth + 62}px`;
            simpleContent.style.minWidth = `${playableWidth + 62}px`;
            simpleContent.style.maxWidth = `${playableWidth + 62}px`; // Prevent extending past song end
            simpleContent.style.minHeight = '80px';
            
            // Add vertical grid lines (matching the piano roll)
            // First, remove any existing grid lines
            const existingGridLines = simpleContent.querySelector('.simple-grid-lines-container');
            if (existingGridLines) {
                existingGridLines.remove();
            }
            
            const gridLinesContainer = document.createElement('div');
            gridLinesContainer.className = 'simple-grid-lines-container';
            gridLinesContainer.style.position = 'absolute';
            gridLinesContainer.style.top = '0';
            gridLinesContainer.style.left = '62px'; // Start after the fake piano keys
            gridLinesContainer.style.width = `${playableWidth}px`;
            gridLinesContainer.style.height = '100%';
            gridLinesContainer.style.pointerEvents = 'none';
            gridLinesContainer.style.zIndex = '0';
            gridLinesContainer.style.overflow = 'visible';
            
            // Use reference BPM (120) since notes are stored at reference timing
            const referenceBPM = 120;
            const beatTime = 60 / referenceBPM; // 0.5s per beat at 120 BPM
            const measureTime = beatTime * timeSignature; // seconds per measure
            
            // Draw ONLY measure lines (bright green), not subdivision lines
            for (let t = 0; t <= songLength; t += measureTime) {
                const x = t * pxPerSecond;
                const line = document.createElement('div');
                line.style.position = 'absolute';
                line.style.left = `${x}px`;
                line.style.top = '0';
                line.style.width = '3px';
                line.style.height = '100%';
                line.style.background = 'rgba(0, 255, 159, 0.15)';
                
                gridLinesContainer.appendChild(line);
            }
            
            // Draw beat subdivision lines (dim)
            const quantization = document.getElementById('noteQuantization').value;
            let subdivisionTime;
            switch (quantization) {
                case 'eighth':
                    subdivisionTime = beatTime / 2; // 8th notes (0.25s)
                    break;
                case 'sixteenth':
                    subdivisionTime = beatTime / 4; // 16th notes (0.125s)
                    break;
                case 'thirtysecond':
                    subdivisionTime = beatTime / 8; // 32nd notes (0.0625s)
                    break;
                default:
                    subdivisionTime = beatTime / 2; // Default to 8th notes
            }
            
            for (let t = subdivisionTime; t <= songLength; t += subdivisionTime) {
                // Skip if this is already a measure line
                if (Math.abs(t % measureTime) < 0.01) continue;
                
                const x = t * pxPerSecond;
                const line = document.createElement('div');
                line.style.position = 'absolute';
                line.style.left = `${x}px`;
                line.style.top = '0';
                line.style.width = '1px';
                line.style.height = '100%';
                line.style.background = 'rgba(255, 255, 255, 0.04)';
                
                gridLinesContainer.appendChild(line);
            }
            
            simpleContent.appendChild(gridLinesContainer);
            
            trackData.notes.forEach((note, idx) => {
                // Get instrument for this note
                const inst = instruments.find(i => i.id === (note.instrument || 1)) || instruments[0];
                
                const noteBlock = document.createElement('div');
                noteBlock.className = 'note-block';
                noteBlock.dataset.noteIndex = idx; // Store actual index
                
                // Position 62px from left (to account for visual piano key area) plus time offset
                const left = 62 + (note.time * pxPerSecond);
                const width = (note.duration || 0.25) * pxPerSecond;
                
                noteBlock.style.left = `${left}px`;
                noteBlock.style.width = `${width}px`;
                noteBlock.style.zIndex = '2'; // Above the fake piano keys
                noteBlock.style.background = inst.color;
                noteBlock.style.borderColor = inst.color;
                
                // Check if this note is selected
                if (selectedNotes.has(note)) {
                    noteBlock.classList.add('selected');
                }
                
                const label = document.createElement('div');
                label.className = 'note-label';
                label.textContent = `${frequencyToNoteName(note.frequency)} (${note.frequency.toFixed(0)}Hz)`;
                noteBlock.appendChild(label);
                
                // Resize handle at the START (left edge)
                const resizeHandleStart = document.createElement('div');
                resizeHandleStart.className = 'resize-handle';
                resizeHandleStart.style.left = '0';
                resizeHandleStart.style.right = 'auto';
                noteBlock.appendChild(resizeHandleStart);
                
                // Resize handle at the END (right edge)  
                const resizeHandleEnd = document.createElement('div');
                resizeHandleEnd.className = 'resize-handle';
                noteBlock.appendChild(resizeHandleEnd);
                
                // Click to select
                noteBlock.addEventListener('click', (e) => {
                    if (!e.target.classList.contains('resize-handle')) {
                        e.stopPropagation();
                        const addToSelection = e.ctrlKey || e.metaKey || e.shiftKey;
                        selectNote(note, channel, addToSelection);
                    }
                });
                
                // Drag to move (only from center, not edges)
                noteBlock.addEventListener('mousedown', (e) => {
                    if (e.target.classList.contains('resize-handle')) return;
                    
                    // Only drag from center area (not near edges)
                    const rect = noteBlock.getBoundingClientRect();
                    const clickX = e.clientX - rect.left;
                    const edgeThreshold = 8; // pixels from edge
                    
                    console.log('Note mousedown, clickX:', clickX, 'width:', rect.width, 'edgeThreshold:', edgeThreshold);
                    
                    if (clickX > edgeThreshold && clickX < rect.width - edgeThreshold) {
                        console.log('Started dragging note, frequency:', note.frequency);
                        
                        // Check if Cmd/Ctrl is held for duplication
                        const isDuplicating = e.ctrlKey || e.metaKey;
                        let originalSelectedNotes = [];
                        
                        // Make sure this note is selected ‚Äî preserve multi-selection if Cmd held
                        if (!selectedNotes.has(note)) {
                            if (isDuplicating) {
                                // Add to existing selection without clearing it
                                selectedNotes.add(note);
                                selectedChannel = channel;
                                visualizeTrack(channel, convertedTracks[channel]);
                            } else {
                                selectNote(note, channel, false);
                            }
                        }
                        
                        // Save original selection before any changes
                        let notesToDrag = Array.from(selectedNotes);
                        
                        if (isDuplicating) {
                            // Save undo state
                            saveUndoState(channel);
                            
                            // Save original notes for potential restoration
                            originalSelectedNotes = notesToDrag.map(n => n);
                            
                            // Duplicate ALL selected notes
                            const duplicates = [];
                            notesToDrag.forEach(n => {
                                const duplicate = JSON.parse(JSON.stringify(n));
                                convertedTracks[channel].notes.push(duplicate);
                                duplicates.push(duplicate);
                            });
                            
                            // Clear old selection and select the duplicates
                            selectedNotes.clear();
                            duplicates.forEach(n => selectedNotes.add(n));
                            
                            // Update notesToDrag to be the duplicates
                            notesToDrag = duplicates;
                            
                            console.log('Duplicated', duplicates.length, 'note(s)');
                        }
                        
                        e.preventDefault();
                        
                        const startX = e.clientX;
                        const startTimes = new Map(notesToDrag.map(n => [n, n.time]));
                        let lastPreviewTime = 0;
                        let hasMoved = false;
                        
                        const onMouseMove = (moveEvent) => {
                            hasMoved = true;
                            const deltaX = moveEvent.clientX - startX;
                            const deltaTime = deltaX / pxPerSecond;
                            
                            // Move all selected notes together
                            notesToDrag.forEach(n => {
                                const originalTime = startTimes.get(n);
                                const rawTime = originalTime + deltaTime;
                                const snappedTime = snapToGrid(rawTime);
                                const newTime = Math.max(0, Math.min(songLength - n.duration, snappedTime));
                                n.time = newTime;
                            });
                            
                            // Re-render to show the dragging notes
                            visualizeTrack(channel, convertedTracks[channel]);
                        };
                        
                        const onMouseUp = () => {
                            console.log('Mouse up, stopping drag');
                            
                            if (hasMoved) {
                                if (!isDuplicating) {
                                    saveUndoState(channel);
                                }
                                notesToDrag.forEach(n => handleNoteOverlap(channel, n, notesToDrag));
                            }
                            
                            visualizeTrack(channel, convertedTracks[channel]);
                            document.removeEventListener('mousemove', onMouseMove);
                            document.removeEventListener('mouseup', onMouseUp);
                        };
                        
                        document.addEventListener('mousemove', onMouseMove);
                        document.addEventListener('mouseup', onMouseUp);
                    }
                });
                
                // Resize from START (left edge)
                let isResizingStart = false;
                let resizeStartTime = 0;
                let resizeStartDuration = 0;
                
                resizeHandleStart.addEventListener('mousedown', (e) => {
                    isResizingStart = true;
                    startX = e.clientX;
                    resizeStartTime = note.time;
                    resizeStartDuration = note.duration;
                    selectNote(note, channel, e.ctrlKey || e.metaKey);
                    e.stopPropagation();
                    e.preventDefault();
                });
                
                document.addEventListener('mousemove', (e) => {
                    if (!isResizingStart) return;
                    
                    const deltaX = e.clientX - startX;
                    const deltaTime = deltaX / pxPerSecond;
                    
                    // Moving start point: adjust both time and duration
                    const newTime = Math.max(0, resizeStartTime + deltaTime);
                    const timeDiff = newTime - resizeStartTime;
                    note.time = newTime;
                    note.duration = Math.max(0.05, resizeStartDuration - timeDiff);
                    
                    noteBlock.style.left = `${62 + (note.time * pxPerSecond)}px`;
                    noteBlock.style.width = `${note.duration * pxPerSecond}px`;
                });
                
                document.addEventListener('mouseup', () => {
                    if (isResizingStart) {
                        saveUndoState(channel);
                        handleNoteOverlap(channel, note);
                        visualizeTrack(channel, convertedTracks[channel]);
                        isResizingStart = false;
                    }
                });
                
                // Resize from END (right edge)
                let isResizingEnd = false;
                let startWidth = 0;
                
                resizeHandleEnd.addEventListener('mousedown', (e) => {
                    isResizingEnd = true;
                    startX = e.clientX;
                    startWidth = note.duration * pxPerSecond;
                    selectNote(note, channel, e.ctrlKey || e.metaKey);
                    e.stopPropagation();
                    e.preventDefault();
                });
                
                document.addEventListener('mousemove', (e) => {
                    if (!isResizingEnd) return;
                    
                    const deltaX = e.clientX - startX;
                    const newWidth = Math.max(10, startWidth + deltaX);
                    const newDuration = newWidth / pxPerSecond;
                    
                    note.duration = Math.min(newDuration, songLength - note.time);
                    noteBlock.style.width = `${note.duration * pxPerSecond}px`;
                });
                
                document.addEventListener('mouseup', () => {
                    if (isResizingEnd) {
                        saveUndoState(channel);
                        handleNoteOverlap(channel, note);
                        visualizeTrack(channel, convertedTracks[channel]);
                        isResizingEnd = false;
                    }
                });
                
                simpleContent.appendChild(noteBlock);
                console.log('Appended note block to', channel, 'simpleContent. Total children now:', simpleContent.children.length);
            });
        }

        function selectNote(note, channel) {
            selectedNote = note;
            selectedChannel = channel;
            
            // Re-render all tracks to update selection
            Object.keys(convertedTracks).forEach(ch => {
                if (convertedTracks[ch]) {
                    visualizeTrack(ch, convertedTracks[ch]);
                }
            });
        }

        // Initialize all tracks
        Object.keys(convertedTracks).forEach(channel => {
            visualizeTrack(channel, convertedTracks[channel]);
        });

        // Initialize instrument system
        renderInstrumentsList();
        selectInstrumentForEditing(1); // Auto-select Default instrument
        document.getElementById('addInstrumentBtn').addEventListener('click', () => {
            addInstrument();
        });
        
        // Preview and Stop buttons
        document.getElementById('previewInstrumentBtn').addEventListener('click', () => {
            if (selectedInstrumentForEditing) {
                previewInstrument(selectedInstrumentForEditing);
            }
        });
        document.getElementById('stopPreviewBtn').addEventListener('click', () => {
            stopInstrumentPreview();
        });
        
        // Solo button functionality
        document.querySelectorAll('.solo-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                e.stopPropagation(); // Don't trigger track expand
                const channel = btn.dataset.channel;
                
                if (soloedChannels.has(channel)) {
                    // Remove from solo
                    soloedChannels.delete(channel);
                    btn.style.background = 'var(--bg-mid)';
                    btn.style.color = 'var(--text-secondary)';
                } else {
                    // Add to solo
                    soloedChannels.add(channel);
                    btn.style.background = 'var(--accent-2)';
                    btn.style.color = 'white';
                }
                
                // Update status
                if (soloedChannels.size === 0) {
                    updateStatus('All tracks playing');
                } else {
                    const soloList = Array.from(soloedChannels).map(c => c.toUpperCase()).join(', ');
                    updateStatus(`Solo: ${soloList}`);
                }
                
                // If currently playing, restart playback to apply solo changes immediately
                if (isPlaying) {
                    const currentTime = audioContext.currentTime - playbackStartTime;
                    
                    // Stop all current notes
                    stopAllScheduledNotes();
                    
                    // Re-schedule all notes with new solo settings
                    Object.keys(convertedTracks).forEach(channel => {
                        const track = convertedTracks[channel];
                        if (track && track.notes) {
                            track.notes.forEach(note => {
                                scheduleNote(channel, note, playbackStartTime);
                            });
                        }
                    });
                }
            });
        });
        
        // Record arm button functionality
        const recordArmedChannels = new Set();
        document.querySelectorAll('.record-arm-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                e.stopPropagation(); // Don't trigger track expand
                const channel = btn.dataset.channel;
                
                if (recordArmedChannels.has(channel)) {
                    // Disarm
                    recordArmedChannels.delete(channel);
                    btn.style.background = 'var(--bg-mid)';
                    btn.style.color = 'var(--text-secondary)';
                } else {
                    // Arm for recording
                    recordArmedChannels.add(channel);
                    btn.style.background = '#ff6b9d';
                    btn.style.color = 'white';
                }
                
                // Update status
                if (recordArmedChannels.size === 0) {
                    updateStatus('No tracks armed for MIDI recording');
                } else {
                    const armedList = Array.from(recordArmedChannels).map(c => c.toUpperCase()).join(', ');
                    updateStatus(`üéπ Armed: ${armedList}`);
                }
            });
        });
        
        // Mute button functionality
        const mutedChannels = new Set();
        document.querySelectorAll('.mute-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                e.stopPropagation(); // Don't trigger track expand
                const channel = btn.dataset.channel;
                
                if (mutedChannels.has(channel)) {
                    // Unmute
                    mutedChannels.delete(channel);
                    btn.style.background = 'var(--bg-mid)';
                    btn.style.color = 'var(--text-secondary)';
                } else {
                    // Mute
                    mutedChannels.add(channel);
                    btn.style.background = '#ff6b9d';
                    btn.style.color = 'white';
                }
                
                // Update status
                if (mutedChannels.size === 0) {
                    updateStatus('All tracks unmuted');
                } else {
                    const mutedList = Array.from(mutedChannels).map(c => c.toUpperCase()).join(', ');
                    updateStatus(`Muted: ${mutedList}`);
                }
                
                // If currently playing, restart playback to apply mute changes immediately
                if (isPlaying) {
                    const currentTime = audioContext.currentTime - playbackStartTime;
                    
                    // Stop all current notes
                    stopAllScheduledNotes();
                    
                    // Re-schedule all notes with new mute settings
                    Object.keys(convertedTracks).forEach(channel => {
                        const track = convertedTracks[channel];
                        if (track && track.notes) {
                            track.notes.forEach(note => {
                                scheduleNote(channel, note, playbackStartTime);
                            });
                        }
                    });
                }
            });
        });
        
        // FTI import
        document.getElementById('importFTIBtn').addEventListener('click', () => {
            document.getElementById('ftiFileInput').click();
        });
        
        document.getElementById('ftiFileInput').addEventListener('change', async (e) => {
            const files = e.target.files;
            for (const file of files) {
                const arrayBuffer = await file.arrayBuffer();
                const instData = parseFTI(arrayBuffer, file.name);
                if (instData) {
                    addInstrument(instData);
                    updateStatus(`üé∏ Imported instrument: ${instData.name}`);
                }
            }
            e.target.value = ''; // Reset so same file can be imported again
        });

        // Track header click handlers for expansion
        document.querySelectorAll('.track-header').forEach(header => {
            console.log('Adding click handler to:', header.dataset.channel);
            header.addEventListener('click', () => {
                console.log('Track header clicked:', header.dataset.channel);
                const channel = header.dataset.channel;
                const track = header.closest('.track');
                const trackContent = trackElements[channel];
                
                console.log('expandedTrack:', expandedTrack, 'channel:', channel);
                
                // Focus this track for paste operations
                focusTrack(channel);
                
                // Toggle expansion
                if (expandedTrack === channel) {
                    // Collapse
                    track.classList.remove('expanded');
                    trackContent.classList.remove('piano-roll-mode');
                    expandedTrack = null;
                    
                    // Clear piano roll elements to prevent them blocking clicks
                    const pianoKeys = document.getElementById(`${channel}PianoKeys`);
                    const pianoGrid = document.getElementById(`${channel}PianoGrid`);
                    const instrumentBar = document.getElementById(`${channel}InstrumentBar`);
                    if (pianoKeys) pianoKeys.innerHTML = '';
                    if (pianoGrid) pianoGrid.innerHTML = '';
                    if (instrumentBar) instrumentBar.style.display = 'none';
                    
                    // Update indicator
                    const indicator = header.querySelector('.track-expand-indicator');
                    indicator.textContent = '‚ñº Click to expand piano roll';
                    
                    // Re-render in simple mode
                    visualizeTrack(channel, convertedTracks[channel]);
                    updateStatus(`Collapsed ${channel.toUpperCase()}`);
                } else {
                    // Collapse any other expanded track first
                    if (expandedTrack) {
                        const prevTrack = document.querySelector(`.track-header[data-channel="${expandedTrack}"]`).closest('.track');
                        const prevContent = trackElements[expandedTrack];
                        prevTrack.classList.remove('expanded');
                        prevContent.classList.remove('piano-roll-mode');
                        
                        const prevIndicator = document.querySelector(`.track-header[data-channel="${expandedTrack}"] .track-expand-indicator`);
                        prevIndicator.textContent = '‚ñº Click to expand piano roll';
                        
                        // Hide previous instrument bar
                        const prevInstrumentBar = document.getElementById(`${expandedTrack}InstrumentBar`);
                        if (prevInstrumentBar) prevInstrumentBar.style.display = 'none';
                        
                        visualizeTrack(expandedTrack, convertedTracks[expandedTrack]);
                    }
                    
                    // Expand this track
                    track.classList.add('expanded');
                    trackContent.classList.add('piano-roll-mode');
                    expandedTrack = channel;
                    
                    // Update indicator
                    const indicator = header.querySelector('.track-expand-indicator');
                    indicator.textContent = '‚ñ≤ Click to collapse';
                    
                    // Render piano roll
                    renderInlinePianoRoll(channel);
                    updateStatus(`Expanded ${channel.toUpperCase()} - Piano Roll Mode`);
                }
            });
        });

        // File upload handler (keeping original functionality)
        loadProjectBtn.addEventListener('change', handleFileUpload);

        async function handleFileUpload(e) {
            const files = Array.from(e.target.files);
            if (files.length === 0) return;
            
            uploadedFiles = files;
            
            // Check for project files or FamiTracker text files
            for (const file of files) {
                // Handle project files (.json, .nes)
                if (file.name.endsWith('.json') || file.name.endsWith('.nes')) {
                    try {
                        const text = await file.text();
                        const projectData = JSON.parse(text);
                        
                        // Restore everything
                        convertedTracks = projectData.tracks || convertedTracks;
                        
                        if (projectData.instruments) {
                            instruments = projectData.instruments;
                            renderInstrumentsList();
                        }
                        
                        songLength = projectData.songLength || songLength;
                        currentDrawingInstrument = projectData.currentDrawingInstrument || currentDrawingInstrument;
                        
                        if (projectData.zoomLevel) {
                            zoomLevel = projectData.zoomLevel;
                            pixelsPerSecond = (zoomLevel / 100) * 50;
                            updateZoomDisplay();
                        }
                        
                        // Update song length input
                        const songLengthInput = document.getElementById('songLengthInput');
                        if (songLengthInput) songLengthInput.value = songLength;
                        if (songLengthDisplay) songLengthDisplay.textContent = `${songLength.toFixed(1)}s`;
                        
                        // Visualize all tracks
                        setTimeout(() => {
                            Object.keys(convertedTracks).forEach(channel => {
                                visualizeTrack(channel, convertedTracks[channel]);
                            });
                        }, 100);
                        
                        updateStatus('‚úì Project loaded successfully');
                        return;
                    } catch (error) {
                        console.error('Error loading project:', error);
                        updateStatus(`‚úó Error loading project: ${error.message}`);
                        return;
                    }
                }
                
                // Handle text .txt exports
                if (file.name.endsWith('.txt')) {
                    try {
                        const text = await file.text();
                        
                        // Check if it's a FamiTracker or NES Music Maker export file
                        if (text.includes('# FamiTracker text export') || text.includes('# NES Music Maker export')) {
                            updateStatus(`<span class="processing">IMPORTING...</span> Parsing FamiTracker file...`);
                            
                            const importedTracks = parseFamiTracker(text);
                            
                            // Load into editor
                            convertedTracks.pulse1 = importedTracks.pulse1;
                            convertedTracks.pulse2 = importedTracks.pulse2;
                            convertedTracks.triangle = importedTracks.triangle;
                            convertedTracks.noise = importedTracks.noise;
                            
                            // Visualize all tracks
                            Object.keys(convertedTracks).forEach(channel => {
                                visualizeTrack(channel, convertedTracks[channel]);
                            });
                            
                            const totalNotes = Object.values(importedTracks).reduce((sum, track) => sum + track.notes.length, 0);
                            updateStatus(`‚úì Imported FamiTracker file: ${totalNotes} notes across 4 channels`);
                            
                            return;
                        }
                    } catch (error) {
                        console.error('Error parsing FamiTracker file:', error);
                        updateStatus(`‚úó Error importing FamiTracker file: ${error.message}`);
                        return;
                    }
                }
            }
            
            updateStatus(`üìÅ Loaded ${files.length} file(s)`);
        }

        // Simplified conversion function (pitch detection)
        async function convertToNES(audioBuffer, channel, quantizeMode) {
            const sampleRate = audioBuffer.sampleRate;
            const channelData = audioBuffer.getChannelData(0);
            const duration = audioBuffer.duration;
            
            // Update song length if audio is longer
            if (duration > songLength) {
                songLength = Math.ceil(duration);
                songLengthInput.value = songLength;
                songLengthDisplay.textContent = `${songLength.toFixed(1)}s`;
            }
            
            const notes = [];
            const windowSize = 2048;
            const hopSize = 512;
            
            for (let i = 0; i < channelData.length - windowSize; i += hopSize) {
                const window = channelData.slice(i, i + windowSize);
                const frequency = detectPitch(window, sampleRate);
                
                if (frequency > 0 && frequency >= 65 && frequency <= 2000) {
                    const time = i / sampleRate;
                    const nesFreq = quantizeToNES(frequency);
                    
                    // Merge with previous note if same frequency and close in time
                    const lastNote = notes[notes.length - 1];
                    if (lastNote && Math.abs(lastNote.frequency - nesFreq) < 5 && (time - (lastNote.time + lastNote.duration)) < 0.05) {
                        lastNote.duration = time - lastNote.time + 0.1;
                    } else {
                        notes.push({
                            frequency: nesFreq,
                            time: time,
                            duration: 0.1,
                            velocity: 0.8
                        });
                    }
                }
            }
            
            return {
                notes: notes,
                duration: duration
            };
        }

        function detectPitch(buffer, sampleRate) {
            // Auto-correlation method
            const correlations = new Array(buffer.length).fill(0);
            
            for (let lag = 0; lag < buffer.length; lag++) {
                for (let i = 0; i < buffer.length - lag; i++) {
                    correlations[lag] += buffer[i] * buffer[i + lag];
                }
            }
            
            // Find first peak after zero crossing
            let maxCorr = 0;
            let maxLag = 0;
            
            for (let lag = 20; lag < correlations.length / 2; lag++) {
                if (correlations[lag] > maxCorr && correlations[lag] > correlations[lag - 1] && correlations[lag] > correlations[lag + 1]) {
                    maxCorr = correlations[lag];
                    maxLag = lag;
                }
            }
            
            if (maxLag === 0) return 0;
            
            return sampleRate / maxLag;
        }

        function quantizeToNES(frequency) {
            let closest = NES_FREQUENCIES[0];
            let minDiff = Math.abs(frequency - closest);
            
            for (let i = 1; i < NES_FREQUENCIES.length; i++) {
                const diff = Math.abs(frequency - NES_FREQUENCIES[i]);
                if (diff < minDiff) {
                    minDiff = diff;
                    closest = NES_FREQUENCIES[i];
                }
            }
            
            return closest;
        }

        // Playback system event listeners
        playBtn.addEventListener('click', () => {
            if (!isPlaying) {
                startPlayback();
            } else {
                pausePlayback();
            }
        });

        stopBtn.addEventListener('click', () => {
            if (isPlaying) {
                stopPlayback();
            } else if (pausedAtTime > 0) {
                // We're paused - clear pause state and reset
                pausedAtTime = 0;
                const playhead = document.getElementById('playhead');
                if (playhead) {
                    playhead.style.display = 'none';
                    playhead.style.left = '0px';
                }
                updateStatus('‚èπ Stopped');
            }
        });

        // Loop button
        const loopBtn = document.getElementById('loopBtn');
        const timelineScrubber = document.getElementById('timelineScrubber');
        const loopRegion = document.getElementById('loopRegion');
        const timelinePlayhead = document.getElementById('timelinePlayhead');
        
        console.log('Loop elements:', {
            loopBtn,
            timelineScrubber,
            loopRegion,
            timelinePlayhead
        });
        
        console.log('timelineScrubber exists?', !!timelineScrubber);
        
        if (!timelineScrubber) {
            console.error('timelineScrubber not found!');
        } else {
            console.log('timelineScrubber found! Setting up...');
        }
        
        // Update loop region visual
        function updateLoopRegionVisual() {
            if (!timelineScrubber || !loopRegion) return;
            
            const scrubberWidth = timelineScrubber.offsetWidth;
            const startPercent = (loopStart / songLength) * 100;
            const endPercent = (loopEnd / songLength) * 100;
            
            loopRegion.style.left = `${startPercent}%`;
            loopRegion.style.width = `${endPercent - startPercent}%`;
            loopRegion.style.display = isLooping ? 'block' : 'none';
        }
        
        // Update playhead position on timeline scrubber
        function updateTimelinePlayhead(time) {
            if (!timelinePlayhead) return;
            
            // Notes are stored at 120 BPM reference, displayed at their reference positions
            // At higher BPM, song plays faster, so we've covered more of the song in the same real time
            const referenceBPM = 120;
            const speedMultiplier = bpm / referenceBPM; // >1 means faster, <1 means slower
            const effectiveTime = time * speedMultiplier; // How far through the song we are
            
            const percent = (effectiveTime / songLength) * 100;
            timelinePlayhead.style.left = `${percent}%`;
        }
        
        if (loopBtn) {
            loopBtn.addEventListener('click', () => {
                isLooping = !isLooping;
                loopBtn.style.background = isLooping ? 'var(--accent-1)' : 'var(--bg-mid)';
                loopBtn.style.color = isLooping ? 'white' : 'var(--text-secondary)';
                updateLoopRegionVisual();
                updateStatus(isLooping ? `üîÅ Loop: ${loopStart.toFixed(1)}s - ${loopEnd.toFixed(1)}s` : 'üîÅ Loop disabled');
            });
        }
        
        // Click on timeline to set loop region
        let isDraggingLoop = false;
        let loopDragStart = 0;
        let hasMovedMouse = false;
        
        if (timelineScrubber) {
            timelineScrubber.addEventListener('mousedown', (e) => {
            console.log('Timeline mousedown!');
            const rect = timelineScrubber.getBoundingClientRect();
            console.log('Scrubber rect:', rect);
            const x = e.clientX - rect.left;
            const clickTime = (x / rect.width) * songLength;
            console.log('Click at x:', x, 'time:', clickTime);
            
            isDraggingLoop = true;
            hasMovedMouse = false;
            loopDragStart = clickTime;
            loopStart = clickTime;
            loopEnd = clickTime;
            
            e.preventDefault();
        });
        
        document.addEventListener('mousemove', (e) => {
            if (!isDraggingLoop) return;
            
            hasMovedMouse = true;
            
            const rect = timelineScrubber.getBoundingClientRect();
            const x = Math.max(0, Math.min(e.clientX - rect.left, rect.width));
            const currentTime = (x / rect.width) * songLength;
            
            if (currentTime < loopDragStart) {
                loopStart = currentTime;
                loopEnd = loopDragStart;
            } else {
                loopStart = loopDragStart;
                loopEnd = currentTime;
            }
            
            console.log('Dragging - loopStart:', loopStart.toFixed(2), 'loopEnd:', loopEnd.toFixed(2));
            
            // Auto-enable looping when you start dragging
            if (!isLooping) {
                isLooping = true;
                loopBtn.style.background = 'var(--accent-1)';
                loopBtn.style.color = 'white';
                console.log('Loop enabled');
            }
            
            updateLoopRegionVisual();
            updateStatus(`üîÅ Loop: ${loopStart.toFixed(1)}s - ${loopEnd.toFixed(1)}s`);
        });
        
        document.addEventListener('mouseup', () => {
            if (isDraggingLoop) {
                isDraggingLoop = false;
                
                // If user just clicked without dragging, turn off loop
                if (!hasMovedMouse) {
                    isLooping = false;
                    loopBtn.style.background = 'var(--bg-mid)';
                    loopBtn.style.color = 'var(--text-secondary)';
                    updateLoopRegionVisual();
                    updateStatus('üîÅ Loop disabled');
                } else {
                    // Ensure minimum loop length if they did drag
                    if (loopEnd - loopStart < 0.1) {
                        loopEnd = loopStart + 0.1;
                    }
                    updateLoopRegionVisual();
                    updateStatus(`üîÅ Loop: ${loopStart.toFixed(1)}s - ${loopEnd.toFixed(1)}s`);
                }
            }
        });
        
            // Initialize visuals
            updateLoopRegionVisual();
            updateTimelinePlayhead(0);
            
            // Render notes on timeline
            const timelineNotesCanvas = document.getElementById('timelineNotesCanvas');
            console.log('timelineNotesCanvas:', timelineNotesCanvas);
            
            if (timelineNotesCanvas) {
                function renderTimelineNotes() {
                    console.log('renderTimelineNotes called');
                    const rect = timelineScrubber.getBoundingClientRect();
                    console.log('Timeline rect:', rect.width, 'x', rect.height);
                    
                    timelineNotesCanvas.width = rect.width;
                    timelineNotesCanvas.height = 30;
                    
                    const ctx = timelineNotesCanvas.getContext('2d');
                    ctx.clearRect(0, 0, timelineNotesCanvas.width, timelineNotesCanvas.height);
                    
                    // Draw each channel's notes
                    const channels = ['pulse1', 'pulse2', 'triangle', 'noise'];
                    const channelHeight = 30 / channels.length;
                    
                    console.log('Drawing notes for channels:', channels);
                    
                    channels.forEach((channel, idx) => {
                        const track = convertedTracks[channel];
                        if (!track || !track.notes) {
                            console.log(channel, 'has no notes');
                            return;
                        }
                        
                        console.log(channel, 'has', track.notes.length, 'notes');
                        
                        const y = idx * channelHeight;
                        
                        track.notes.forEach(note => {
                            // Skip notes that start beyond song length
                            if (note.time > songLength) return;
                            
                            const inst = instruments.find(i => i.id === (note.instrument || 1)) || instruments[0];
                            const x = (note.time / songLength) * timelineNotesCanvas.width;
                            const noteEnd = Math.min(note.time + note.duration, songLength);
                            const width = Math.max(1, ((noteEnd - note.time) / songLength) * timelineNotesCanvas.width);
                            
                            console.log('Drawing note at x:', x, 'width:', width, 'color:', inst.color);
                            
                            ctx.fillStyle = inst.color + 'cc'; // Add transparency
                            ctx.fillRect(x, y, width, channelHeight);
                        });
                    });
                    
                    console.log('Finished rendering timeline notes');
                }
                
                // Initial render
                renderTimelineNotes();
                
                // Re-render when window resizes
                window.addEventListener('resize', renderTimelineNotes);
                
                // Store function globally so we can call it when notes change
                window.renderTimelineNotes = renderTimelineNotes;
            }
        } // end if (timelineScrubber)

        function stopAllScheduledNotes() {
            // Stop all currently playing audio sources
            scheduledNotes.forEach(({ osc, gain }) => {
                try {
                    osc.stop();
                    gain.disconnect();
                } catch (e) {
                    // Note may have already stopped naturally
                }
            });
            scheduledNotes = [];
        }

        function scheduleClickTrack(startTime) {
            // Notes are stored at 120 BPM reference, clicks should match
            const referenceBPM = 120;
            const referenceBeatInterval = 60 / referenceBPM; // 0.5s per beat
            const tempoScale = referenceBPM / bpm; // Same scale used for notes
            
            // Calculate beats needed to cover the song at reference timing
            const totalBeats = Math.ceil(songLength / referenceBeatInterval);
            
            for (let i = 0; i < totalBeats; i++) {
                // Click at reference time, then scale it (same as notes)
                const referenceClickTime = i * referenceBeatInterval;
                const clickTime = startTime + (referenceClickTime * tempoScale);
                
                // Create a short click sound
                const osc = audioContext.createOscillator();
                const gain = audioContext.createGain();
                
                // Beat pattern depends on time signature
                const beatInMeasure = i % timeSignature;
                if (beatInMeasure === 0) {
                    osc.frequency.value = 1200; // Downbeat - highest pitch
                } else {
                    osc.frequency.value = 800; // Other beats - lower pitch
                }
                
                // Short envelope
                gain.gain.setValueAtTime(0, clickTime);
                gain.gain.linearRampToValueAtTime(0.1, clickTime + 0.001);
                gain.gain.exponentialRampToValueAtTime(0.01, clickTime + 0.05);
                
                osc.connect(gain);
                gain.connect(audioContext.destination);
                
                osc.start(clickTime);
                osc.stop(clickTime + 0.05);
                
                // Track so we can stop it
                scheduledNotes.push({ osc, gain });
            }
        }
        
        function startPlayback() {
            console.log('startPlayback called');
            console.log('playBtn:', playBtn);
            
            // Resume audio context if suspended (required by browsers)
            if (audioContext.state === 'suspended') {
                audioContext.resume().then(() => {
                    console.log('AudioContext resumed');
                });
            }
            
            isPlaying = true;
            if (playBtn) {
                playBtn.textContent = '‚è∏';
            }
            
            // Determine start position: paused position, loop start, or beginning
            let startTime;
            if (pausedAtTime > 0) {
                // Resume from where we paused
                startTime = pausedAtTime;
                pausedAtTime = 0; // Clear pause position
            } else if (isLooping) {
                startTime = loopStart;
            } else {
                startTime = 0;
            }
            
            playbackStartTime = audioContext.currentTime - startTime;
            console.log('playbackStartTime:', playbackStartTime, 'starting at:', startTime);
            
            const playhead = document.getElementById('playhead');
            if (playhead) {
                playhead.style.display = 'block';
            }
            
            // Schedule all notes
            console.log('Scheduling notes for channels:', Object.keys(convertedTracks));
            Object.keys(convertedTracks).forEach(channel => {
                const track = convertedTracks[channel];
                if (track && track.notes) {
                    track.notes.forEach(note => {
                        scheduleNote(channel, note, playbackStartTime);
                    });
                }
            });
            
            // Schedule click track if enabled
            const clickTrackEnabled = document.getElementById('clickTrack')?.checked;
            if (clickTrackEnabled) {
                scheduleClickTrack(playbackStartTime);
            }
            
            // Animate playhead
            function animate() {
                if (!isPlaying) return;
                
                const elapsed = audioContext.currentTime - playbackStartTime;
                
                // Update timeline scrubber playhead
                updateTimelinePlayhead(elapsed);
                
                // Find the first track content to get the base position
                const firstTrackContent = document.querySelector('.track-content');
                
                if (firstTrackContent) {
                    const trackRect = firstTrackContent.getBoundingClientRect();
                    const scrollLeft = firstTrackContent.scrollLeft || 0;
                    
                    // At higher BPM, we move through the song faster
                    const referenceBPM = 120;
                    const speedMultiplier = bpm / referenceBPM;
                    const effectiveElapsed = elapsed * speedMultiplier;
                    
                    // Compensate for audio latency
                    const latencyCompensation = 0.04 * pixelsPerSecond;
                    
                    // Position calculation:
                    // trackRect.left = left edge of track in viewport
                    // scrollLeft = how many pixels are scrolled (hidden to the left)
                    // 62 = piano keys width
                    // We want: left edge of track + piano keys + (elapsed time - scrolled amount)
                    const position = trackRect.left + 62 + (effectiveElapsed * pixelsPerSecond) - scrollLeft - latencyCompensation;
                    playhead.style.left = `${position}px`;
                }
                
                // Check if we should loop
                if (isLooping && elapsed >= loopEnd) {
                    // Stop current playback
                    stopAllScheduledNotes();
                    
                    // Restart from loop start
                    playbackStartTime = audioContext.currentTime - loopStart;
                    
                    // Re-schedule all notes
                    Object.keys(convertedTracks).forEach(channel => {
                        const track = convertedTracks[channel];
                        if (track && track.notes) {
                            track.notes.forEach(note => {
                                scheduleNote(channel, note, playbackStartTime);
                            });
                        }
                    });
                    
                    // Re-schedule click track if enabled
                    const clickTrackEnabled = document.getElementById('clickTrack')?.checked;
                    if (clickTrackEnabled) {
                        scheduleClickTrack(playbackStartTime);
                    }
                    
                    animationFrameId = requestAnimationFrame(animate);
                    return;
                }
                
                if (elapsed >= songLength) {
                    stopPlayback();
                    return;
                }
                
                animationFrameId = requestAnimationFrame(animate);
            }
            animate();
            
            updateStatus('‚ñ∂ Playing...');
        }

        function pausePlayback() {
            isPlaying = false;
            playBtn.textContent = '‚ñ∂';
            
            // Save current position for resume
            pausedAtTime = audioContext.currentTime - playbackStartTime;
            
            // Stop all scheduled audio (including click track)
            stopAllScheduledNotes();
            
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
            
            updateStatus(`‚è∏ Paused at ${pausedAtTime.toFixed(2)}s`);
        }

        function stopPlayback() {
            isPlaying = false;
            playBtn.textContent = '‚ñ∂';
            
            // Clear pause position (stop means restart from beginning)
            pausedAtTime = 0;
            
            // Stop all scheduled notes
            scheduledNotes.forEach(({ osc, gain }) => {
                try {
                    osc.stop();
                    gain.disconnect();
                } catch (e) {}
            });
            scheduledNotes = [];
            
            const playhead = document.getElementById('playhead');
            playhead.style.display = 'none';
            playhead.style.left = '0px';
            
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
            
            updateStatus('‚èπ Stopped');
        }

        function scheduleNote(channel, note, startTime) {
            // Skip if channel is muted
            if (mutedChannels.has(channel)) {
                return;
            }
            
            // Skip if any channels are soloed and this isn't one of them
            if (soloedChannels.size > 0 && !soloedChannels.has(channel)) {
                return;
            }
            
            // Tempo scaling: notes are stored at 120 BPM reference, scale for current BPM
            const referenceBPM = 120;
            const tempoScale = referenceBPM / bpm; // Faster BPM = smaller scale = shorter times
            
            const noteStart = startTime + (note.time * tempoScale);
            const noteEnd = noteStart + (note.duration * tempoScale);
            const scaledDuration = note.duration * tempoScale;
            
            // Get instrument for this note
            const inst = instruments.find(i => i.id === (note.instrument || 1)) || instruments[0];
            
            // Check if we need to slide to next note
            let slideToFreq = null;
            let slideDuration = 0;
            if (note.slideToNext && note.slideTargetFreq && note.slideTargetTime) {
                slideToFreq = note.slideTargetFreq;
                slideDuration = (note.slideTargetTime - (note.time + note.duration)) * tempoScale;
            }
            
            if (channel === 'noise') {
                // Create white noise for noise channel
                const bufferSize = audioContext.sampleRate * scaledDuration;
                const noiseBuffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
                const output = noiseBuffer.getChannelData(0);
                
                // Generate white noise
                for (let i = 0; i < bufferSize; i++) {
                    output[i] = Math.random() * 2 - 1;
                }
                
                const noiseSource = audioContext.createBufferSource();
                noiseSource.buffer = noiseBuffer;
                
                // Add bandpass filter to simulate different noise pitches
                const filter = audioContext.createBiquadFilter();
                filter.type = 'bandpass';
                filter.frequency.value = note.frequency; // Use the note's frequency to filter the noise
                filter.Q.value = 1; // Bandwidth
                
                const gain = audioContext.createGain();
                
                // Apply volume envelope if present
                if (inst.volumeEnv) {
                    applyVolumeEnvelope(gain, noteStart, scaledDuration, inst.volumeEnv, note.velocity);
                } else {
                    // Default envelope
                    gain.gain.setValueAtTime(0, noteStart);
                    gain.gain.linearRampToValueAtTime(note.velocity * 0.3, noteStart + 0.01);
                    gain.gain.linearRampToValueAtTime(note.velocity * 0.2, noteEnd - 0.01);
                    gain.gain.linearRampToValueAtTime(0, noteEnd);
                }
                
                noiseSource.connect(filter);
                filter.connect(gain);
                gain.connect(audioContext.destination);
                
                noiseSource.start(noteStart);
                noiseSource.stop(noteEnd);
                
                scheduledNotes.push({ osc: noiseSource, gain });
            } else {
                // Use oscillator for pulse and triangle channels
                const osc = audioContext.createOscillator();
                const gain = audioContext.createGain();
                
                // Set initial waveform
                if (channel === 'pulse1' || channel === 'pulse2') {
                    // Apply duty cycle (will be modulated by envelope if present)
                    const dutyCycle = inst.dutyCycle;
                    const dutyCyclePercent = [0.125, 0.25, 0.5, 0.75][dutyCycle];
                    
                    const real = new Float32Array(32);
                    const imag = new Float32Array(32);
                    
                    for (let n = 1; n < 32; n++) {
                        imag[n] = (2 / (n * Math.PI)) * Math.sin(n * Math.PI * dutyCyclePercent);
                    }
                    
                    const wave = audioContext.createPeriodicWave(real, imag);
                    osc.setPeriodicWave(wave);
                } else if (channel === 'triangle') {
                    osc.type = 'triangle';
                }
                
                osc.frequency.value = note.frequency;
                
                // Apply pitch slide if slideToNext is set
                if (slideToFreq && slideDuration > 0) {
                    // Extend the oscillator to cover the slide duration
                    const slideEnd = noteEnd + slideDuration;
                    
                    // Slide pitch from current note to next note
                    osc.frequency.setValueAtTime(note.frequency, noteEnd);
                    osc.frequency.exponentialRampToValueAtTime(slideToFreq, slideEnd);
                    
                    // Volume envelope during slide
                    gain.gain.setValueAtTime(0, noteStart);
                    gain.gain.linearRampToValueAtTime(note.velocity * 0.3, noteStart + 0.01);
                    gain.gain.setValueAtTime(note.velocity * 0.2, noteEnd);
                    gain.gain.linearRampToValueAtTime(note.velocity * 0.2, slideEnd - 0.01);
                    gain.gain.linearRampToValueAtTime(0, slideEnd);
                    
                    osc.start(noteStart);
                    osc.stop(slideEnd);
                } else {
                    // No slide - apply normal envelopes
                    
                    // Apply pitch envelope if present
                    if (inst.pitchEnv && channel !== 'triangle') {
                        applyPitchEnvelope(osc, noteStart, scaledDuration, inst.pitchEnv, note.frequency);
                    }
                    
                    // Apply arpeggio if present
                    if (inst.arpeggioEnv) {
                        applyArpeggioEnvelope(osc, noteStart, scaledDuration, inst.arpeggioEnv, note.frequency);
                    }
                    
                    // Apply volume envelope if present
                    if (inst.volumeEnv) {
                        applyVolumeEnvelope(gain, noteStart, scaledDuration, inst.volumeEnv, note.velocity);
                    } else {
                        // Default envelope
                        gain.gain.setValueAtTime(0, noteStart);
                        gain.gain.linearRampToValueAtTime(note.velocity * 0.3, noteStart + 0.01);
                        gain.gain.linearRampToValueAtTime(note.velocity * 0.2, noteEnd - 0.01);
                        gain.gain.linearRampToValueAtTime(0, noteEnd);
                    }
                    
                    osc.start(noteStart);
                    osc.stop(noteEnd);
                }
                
                osc.connect(gain);
                gain.connect(audioContext.destination);
                
                scheduledNotes.push({ osc, gain });
            }
        }
        
        // Apply volume envelope to a gain node
        function applyVolumeEnvelope(gainNode, startTime, duration, envelope, velocity) {
            const frameTime = 1 / 60; // FamiTracker runs at 60 FPS
            const data = envelope.data;
            const loopPoint = envelope.loop;
            
            gainNode.gain.setValueAtTime(0, startTime);
            
            let time = startTime;
            for (let i = 0; i < data.length && (time - startTime) < duration; i++) {
                // Volume values in FTI are 0-15
                const volume = (data[i] / 15) * velocity * 0.3;
                gainNode.gain.linearRampToValueAtTime(volume, time);
                time += frameTime;
                
                // Handle loop
                if (loopPoint >= 0 && i === data.length - 1 && (time - startTime) < duration) {
                    i = loopPoint - 1; // Will be incremented back to loopPoint
                }
            }
            
            // Fade out at the end
            gainNode.gain.linearRampToValueAtTime(0, startTime + duration);
        }
        
        // Apply pitch envelope to an oscillator
        function applyPitchEnvelope(osc, startTime, duration, envelope, baseFreq) {
            const frameTime = 1 / 60;
            const data = envelope.data;
            const loopPoint = envelope.loop;
            
            let time = startTime;
            for (let i = 0; i < data.length && (time - startTime) < duration; i++) {
                // Pitch values are in semitones (can be negative)
                const semitoneOffset = data[i];
                const freq = baseFreq * Math.pow(2, semitoneOffset / 12);
                osc.frequency.setValueAtTime(freq, time);
                time += frameTime;
                
                // Handle loop
                if (loopPoint >= 0 && i === data.length - 1 && (time - startTime) < duration) {
                    i = loopPoint - 1;
                }
            }
        }
        
        // Apply arpeggio envelope (chord effects)
        function applyArpeggioEnvelope(osc, startTime, duration, envelope, baseFreq) {
            const frameTime = 1 / 60;
            const data = envelope.data;
            const loopPoint = envelope.loop;
            
            let time = startTime;
            for (let i = 0; i < data.length && (time - startTime) < duration; i++) {
                // Arpeggio values are in semitones
                const semitoneOffset = data[i];
                const freq = baseFreq * Math.pow(2, semitoneOffset / 12);
                osc.frequency.setValueAtTime(freq, time);
                time += frameTime;
                
                // Handle loop
                if (loopPoint >= 0 && i === data.length - 1 && (time - startTime) < duration) {
                    i = loopPoint - 1;
                }
            }
        }

        // Play a note preview immediately (for clicking notes, not timeline playback)
        function playNotePreview(channel, frequency, duration = 0.2, instId = 0) {
            const now = audioContext.currentTime;
            const noteEnd = now + duration;
            
            // Get instrument
            const inst = instruments.find(i => i.id === instId) || instruments[0];
            
            if (channel === 'noise') {
                // Create white noise for noise channel
                const bufferSize = audioContext.sampleRate * duration;
                const noiseBuffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
                const output = noiseBuffer.getChannelData(0);
                
                // Generate white noise
                for (let i = 0; i < bufferSize; i++) {
                    output[i] = Math.random() * 2 - 1;
                }
                
                const noiseSource = audioContext.createBufferSource();
                noiseSource.buffer = noiseBuffer;
                
                // Add bandpass filter to simulate different noise pitches
                const filter = audioContext.createBiquadFilter();
                filter.type = 'bandpass';
                filter.frequency.value = frequency; // Use the frequency to filter the noise
                filter.Q.value = 1; // Bandwidth
                
                const gain = audioContext.createGain();
                
                // Apply volume envelope if present
                if (inst.volumeEnv) {
                    applyVolumeEnvelope(gain, now, duration, inst.volumeEnv, 0.8);
                } else {
                    gain.gain.setValueAtTime(0, now);
                    gain.gain.linearRampToValueAtTime(0.2, now + 0.01);
                    gain.gain.linearRampToValueAtTime(0.15, noteEnd - 0.01);
                    gain.gain.linearRampToValueAtTime(0, noteEnd);
                }
                
                noiseSource.connect(filter);
                filter.connect(gain);
                gain.connect(audioContext.destination);
                
                noiseSource.start(now);
                noiseSource.stop(noteEnd);
            } else {
                // Use oscillator for pulse and triangle
                const osc = audioContext.createOscillator();
                const gain = audioContext.createGain();
                
                // Set waveform based on channel
                if (channel === 'pulse1' || channel === 'pulse2') {
                    // Create custom waveform with duty cycle
                    const dutyCyclePercent = [0.125, 0.25, 0.5, 0.75][inst.dutyCycle];
                    
                    // Create a pulse wave with specified duty cycle
                    const real = new Float32Array(32);
                    const imag = new Float32Array(32);
                    
                    // Generate Fourier coefficients for pulse wave
                    for (let n = 1; n < 32; n++) {
                        imag[n] = (2 / (n * Math.PI)) * Math.sin(n * Math.PI * dutyCyclePercent);
                    }
                    
                    const wave = audioContext.createPeriodicWave(real, imag);
                    osc.setPeriodicWave(wave);
                } else if (channel === 'triangle') {
                    osc.type = 'triangle';
                }
                
                osc.frequency.value = frequency;
                
                // Apply pitch envelope if present
                if (inst.pitchEnv && channel !== 'triangle') {
                    applyPitchEnvelope(osc, now, duration, inst.pitchEnv, frequency);
                }
                
                // Apply arpeggio if present
                if (inst.arpeggioEnv) {
                    applyArpeggioEnvelope(osc, now, duration, inst.arpeggioEnv, frequency);
                }
                
                // Apply volume envelope if present
                if (inst.volumeEnv) {
                    applyVolumeEnvelope(gain, now, duration, inst.volumeEnv, 0.8);
                } else {
                    gain.gain.setValueAtTime(0, now);
                    gain.gain.linearRampToValueAtTime(0.2, now + 0.01);
                    gain.gain.linearRampToValueAtTime(0.15, noteEnd - 0.01);
                    gain.gain.linearRampToValueAtTime(0, noteEnd);
                }
                
                osc.connect(gain);
                gain.connect(audioContext.destination);
                
                osc.start(now);
                osc.stop(noteEnd);
                
                // Track this preview node for cleanup
                if (!window.currentPreviewNodes) window.currentPreviewNodes = [];
                window.currentPreviewNodes.push(osc);
                window.currentPreviewNodes.push(gain);
            }
            
            // Track noise preview nodes too
            if (channel === 'noise' && typeof noiseSource !== 'undefined') {
                if (!window.currentPreviewNodes) window.currentPreviewNodes = [];
                window.currentPreviewNodes.push(noiseSource);
                window.currentPreviewNodes.push(gain);
                window.currentPreviewNodes.push(filter);
            }
        }

        // Help button
        const helpBtn = document.getElementById('helpBtn');
        if (helpBtn) {
            helpBtn.addEventListener('click', () => {
                const helpOverlay = document.createElement('div');
                helpOverlay.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    right: 0;
                    bottom: 0;
                    background: rgba(0, 0, 0, 0.9);
                    z-index: 10000;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    padding: 20px;
                `;
                
                helpOverlay.innerHTML = `
                <div style="background: var(--bg-mid); border: 2px solid var(--accent-1); border-radius: 8px; padding: 30px; max-width: 600px; max-height: 80vh; overflow-y: auto;">
                    <h2 style="color: var(--accent-1); margin-bottom: 20px; font-family: 'Press Start 2P', cursive; font-size: 1.2rem;">‚å®Ô∏è KEYBOARD SHORTCUTS</h2>
                    
                    <div style="display: grid; grid-template-columns: auto 1fr; gap: 15px 20px; font-family: 'VT323', monospace; font-size: 1.1rem;">
                        <strong style="color: var(--accent-4);">PLAYBACK:</strong><span></span>
                        <span style="color: var(--accent-1);">Spacebar</span><span>Play / Stop</span>
                        
                        <strong style="color: var(--accent-4); margin-top: 15px;">SELECTION:</strong><span></span>
                        <span style="color: var(--accent-3);">Click note</span><span>Select single note</span>
                        <span style="color: var(--accent-3);">Ctrl/Cmd + Click</span><span>Add note to selection</span>
                        <span style="color: var(--accent-3);">Ctrl/Cmd + A</span><span>Select all notes</span>
                        <span style="color: var(--accent-2);">Escape</span><span>Deselect all</span>
                        
                        <strong style="color: var(--accent-4); margin-top: 15px;">EDITING:</strong><span></span>
                        <span style="color: var(--accent-2);">Delete / Backspace</span><span>Delete selected notes</span>
                        <span style="color: var(--accent-2);">Ctrl/Cmd + Z</span><span>Undo</span>
                        <span style="color: var(--accent-2);">Ctrl/Cmd + Shift + Z</span><span>Redo</span>
                        <span style="color: var(--accent-2);">Ctrl/Cmd + C</span><span>Copy notes</span>
                        <span style="color: var(--accent-2);">Ctrl/Cmd + X</span><span>Cut notes</span>
                        <span style="color: var(--accent-2);">Ctrl/Cmd + V</span><span>Paste notes</span>
                        <span style="color: var(--accent-2);">Ctrl/Cmd + D</span><span>Duplicate notes</span>
                        
                        <strong style="color: var(--accent-4); margin-top: 15px;">MOVEMENT:</strong><span></span>
                        <span style="color: var(--accent-1);">Arrow Left/Right</span><span>Move selected notes (0.1s)</span>
                        <span style="color: var(--accent-1);">Arrow Up/Down</span><span>Change pitch (1 semitone)</span>
                        <span style="color: var(--accent-1);">Shift + Arrows</span><span>Fine movement (0.01s)</span>
                        
                        <strong style="color: var(--accent-4); margin-top: 15px;">ADDING NOTES:</strong><span></span>
                        <span style="color: var(--accent-3);">Click track header</span><span>Expand/collapse piano roll</span>
                        <span style="color: var(--accent-3);">Click timeline</span><span>Add note (simple mode)</span>
                        <span style="color: var(--accent-3);">Click piano grid</span><span>Add note with pitch</span>
                        <span style="color: var(--accent-3);">Drag note</span><span>Move time + pitch</span>
                        <span style="color: var(--accent-3);">Drag left edge</span><span>Resize from start</span>
                        <span style="color: var(--accent-3);">Drag right edge</span><span>Resize from end</span>
                        <span style="color: var(--accent-3);">Double-click note</span><span>Manual frequency entry</span>
                        <span style="color: var(--accent-3);">S</span><span>Add pitch slide to next note</span>
                        <span style="color: var(--accent-3);">X</span><span>Remove pitch slide</span>
                        <span style="color: var(--accent-1);">1-9</span><span>Assign instrument to selected notes</span>
                        
                        <strong style="color: var(--accent-4); margin-top: 15px;">ENVELOPE DRAWING:</strong><span></span>
                        <span style="color: var(--accent-3);">Click & Drag</span><span>Draw envelope curve</span>
                        <span style="color: var(--accent-3);">Shift + Drag</span><span>Draw horizontal line (sustain)</span>
                        <span style="color: var(--accent-3);">Alt + Drag</span><span>Staccato pattern (on/off gate)</span>
                    </div>
                    
                    <button id="closeHelp" style="width: 100%; margin-top: 30px; padding: 15px; background: var(--accent-1); color: var(--bg-dark); border: none; border-radius: 4px; cursor: pointer; font-weight: bold; font-size: 1rem;">
                        CLOSE
                    </button>
                </div>
            `;
            
            document.body.appendChild(helpOverlay);
            
            document.getElementById('closeHelp').addEventListener('click', () => {
                helpOverlay.remove();
            });
            
            helpOverlay.addEventListener('click', (e) => {
                if (e.target === helpOverlay) {
                    helpOverlay.remove();
                }
            });
        });
        } else {
            console.error('helpBtn not found');
        }

        // Tap tempo
        if (tapTempoBtn) {
            tapTempoBtn.addEventListener('click', () => {
            const now = Date.now();
            tapTimes.push(now);
            
            // Keep only last 4 taps
            if (tapTimes.length > 4) {
                tapTimes.shift();
            }
            
            // Calculate average interval
            if (tapTimes.length >= 2) {
                const intervals = [];
                for (let i = 1; i < tapTimes.length; i++) {
                    intervals.push(tapTimes[i] - tapTimes[i - 1]);
                }
                const avgInterval = intervals.reduce((a, b) => a + b, 0) / intervals.length;
                const newBpm = Math.round(60000 / avgInterval);
                
                bpmInput.value = Math.max(60, Math.min(240, newBpm));
                bpm = parseInt(bpmInput.value);
                updateTimelineGrid();
                updateStatus(`‚ô© Tempo set to ${bpm} BPM`);
            }
            
            // Reset after 2 seconds of no taps
            clearTimeout(tapTimeout);
            tapTimeout = setTimeout(() => {
                tapTimes = [];
            }, 2000);
        });
        
        // BPM input change listener
        if (bpmInput) {
            bpmInput.addEventListener('input', (e) => {
                bpm = parseInt(e.target.value) || 120;
                updateTimelineGrid();
                
                // Re-render expanded piano roll if any
                if (expandedTrack) {
                    renderInlinePianoRoll(expandedTrack);
                }
            });
            
            bpmInput.addEventListener('change', (e) => {
                bpm = parseInt(e.target.value) || 120;
                updateTimelineGrid();
                
                // Re-render expanded piano roll if any
                if (expandedTrack) {
                    renderInlinePianoRoll(expandedTrack);
                }
                
                updateStatus(`BPM set to ${bpm}`);
            });
            
            // Allow Enter key to apply BPM changes
            bpmInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.target.blur(); // Remove focus to apply changes
                }
            });
        }
        
        // Prevent checkboxes from keeping focus after clicking
        const clickTrack = document.getElementById('clickTrack');
        const midiQuantize = document.getElementById('midiQuantize');
        
        if (clickTrack) {
            clickTrack.addEventListener('click', (e) => {
                e.target.blur(); // Immediately remove focus after clicking
            });
        }
        
        if (midiQuantize) {
            midiQuantize.addEventListener('click', (e) => {
                e.target.blur(); // Immediately remove focus after clicking
            });
        }
        }

        // Microphone recording (simplified - keeping from original)
        let currentMediaRecorder = null;
        
        // ============================================
        // MIDI SUPPORT
        // ============================================
        
        // Convert MIDI note number to frequency
        function midiNoteToFrequency(midiNote) {
            return 440 * Math.pow(2, (midiNote - 69) / 12);
        }
        
        // Find closest NES frequency to a given frequency
        function findClosestNESFrequency(freq) {
            let closestIdx = 0;
            let minDiff = Math.abs(freq - NES_FREQUENCIES[0]);
            
            for (let i = 1; i < NES_FREQUENCIES.length; i++) {
                const diff = Math.abs(freq - NES_FREQUENCIES[i]);
                if (diff < minDiff) {
                    minDiff = diff;
                    closestIdx = i;
                }
            }
            
            return NES_FREQUENCIES[closestIdx];
        }
        
        // Initialize MIDI
        async function initMIDI() {
            const midiStatus = document.getElementById('midiStatus');
            
            if (!navigator.requestMIDIAccess) {
                midiStatus.textContent = 'üéπ MIDI: Not supported';
                midiStatus.style.color = '#ff6b9d';
                return;
            }
            
            try {
                // Only request access if we don't have it yet
                if (!midiAccess) {
                    midiAccess = await navigator.requestMIDIAccess();
                    
                    // Listen for device connections/disconnections (attach once)
                    midiAccess.onstatechange = (e) => {
                        // Only refresh if a device was connected or disconnected
                        if (e.port.state === 'connected' || e.port.state === 'disconnected') {
                            console.log('MIDI device state changed:', e.port.name, e.port.state);
                            updateMIDIStatus();
                        }
                    };
                }
                
                updateMIDIStatus();
                
            } catch (err) {
                // MIDI not available - this is normal in Firefox or without devices
                console.log('MIDI not available:', err.message);
                midiStatus.textContent = 'üéπ MIDI: Not available';
                midiStatus.style.color = 'var(--text-secondary)';
            }
        }
        
        // Update MIDI status display (separated from initialization)
        function updateMIDIStatus() {
            const midiStatus = document.getElementById('midiStatus');
            if (!midiAccess) return;
            
            const inputs = Array.from(midiAccess.inputs.values());
            
            if (inputs.length === 0) {
                midiStatus.textContent = 'üéπ MIDI: No devices';
                midiStatus.style.color = '#ffd700';
            } else {
                const deviceName = inputs[0].name.substring(0, 20); // First 20 chars
                midiStatus.textContent = `üéπ ${deviceName}`;
                midiStatus.style.color = '#00ff9f';
                midiStatus.title = inputs.map(i => i.name).join(', '); // Show all in tooltip
                
                inputs.forEach(input => {
                    // Attach MIDI message handler
                    input.onmidimessage = handleMIDIMessage;
                });
            }
        }
        
        // Handle incoming MIDI messages
        function handleMIDIMessage(event) {
            const [status, note, velocity] = event.data;
            const command = status >> 4;
            
            // Note On (command = 9, velocity > 0)
            if (command === 9 && velocity > 0) {
                handleMIDINoteOn(note, velocity);
            }
            // Note Off (command = 8, or command = 9 with velocity = 0)
            else if (command === 8 || (command === 9 && velocity === 0)) {
                handleMIDINoteOff(note);
            }
        }
        
        // Handle MIDI note on
        function handleMIDINoteOn(midiNote, velocity) {
            const freq = midiNoteToFrequency(midiNote);
            const nesFreq = findClosestNESFrequency(freq);
            
            // Play preview on all armed channels
            if (recordArmedChannels.size > 0) {
                const firstArmed = Array.from(recordArmedChannels)[0];
                playNotePreview(firstArmed, nesFreq, 0.1, currentDrawingInstrument);
            }
            
            // If recording, track this note for all armed channels
            if (isMidiRecording && recordArmedChannels.size > 0) {
                const currentTime = (audioContext.currentTime - midiRecordStartTime);
                midiActiveNotes.set(midiNote, {
                    startTime: currentTime,
                    frequency: nesFreq,
                    channels: Array.from(recordArmedChannels) // Record which channels to add to
                });
                console.log(`MIDI Note On: ${midiNote} -> ${frequencyToNoteName(nesFreq)} at ${currentTime.toFixed(2)}s`);
            }
        }
        
        // Handle MIDI note off
        function handleMIDINoteOff(midiNote) {
            if (!isMidiRecording || !midiActiveNotes.has(midiNote)) return;
            
            const noteData = midiActiveNotes.get(midiNote);
            const currentTime = (audioContext.currentTime - midiRecordStartTime);
            const duration = currentTime - noteData.startTime;
            
            if (duration < 0.05) return; // Ignore very short notes
            
            const shouldQuantize = document.getElementById('midiQuantize').checked;
            
            let startTime = noteData.startTime;
            let noteDuration = duration;
            
            // Quantize if enabled
            if (shouldQuantize) {
                const gridSize = 0.25; // 8th notes
                startTime = Math.round(startTime / gridSize) * gridSize;
                noteDuration = Math.max(gridSize, Math.round(noteDuration / gridSize) * gridSize);
            }
            
            // Add the note to all armed channels
            noteData.channels.forEach(channel => {
                const note = {
                    frequency: noteData.frequency,
                    time: startTime,
                    duration: noteDuration,
                    velocity: 0.8,
                    instrument: currentDrawingInstrument
                };
                
                convertedTracks[channel].notes.push(note);
                handleNoteOverlap(channel, note);
                
                console.log(`MIDI Note Off: Added note ${frequencyToNoteName(noteData.frequency)} to ${channel} at ${startTime.toFixed(2)}s, duration ${noteDuration.toFixed(2)}s`);
                
                // Update display if this track is expanded
                if (expandedTrack === channel) {
                    renderInlinePianoRoll(channel);
                } else {
                    visualizeTrack(channel, convertedTracks[channel]);
                }
            });
            
            midiActiveNotes.delete(midiNote);
        }
        
        // Initialize MIDI on page load
        initMIDI();
        
        // ============================================
        // AUTO-SAVE / AUTO-RESTORE
        // ============================================
        
        function saveProject() {
            const projectData = {
                tracks: convertedTracks,
                instruments: instruments,
                songLength: songLength,
                bpm: bpm,
                timeSignature: timeSignature,
                quantization: document.getElementById('noteQuantization')?.value || 'eighth',
                currentDrawingInstrument: currentDrawingInstrument,
                pixelsPerSecond: pixelsPerSecond,
                zoomLevel: zoomLevel,
                timestamp: Date.now()
            };
            
            try {
                localStorage.setItem('nes-music-maker-autosave', JSON.stringify(projectData));
                console.log('Project auto-saved');
            } catch (e) {
                console.error('Failed to auto-save:', e);
            }
        }
        
        function loadProject() {
            // Check if we should skip restore (e.g., after clicking "New")
            const skipRestore = localStorage.getItem('nes-music-maker-skip-restore');
            if (skipRestore) {
                localStorage.removeItem('nes-music-maker-skip-restore');
                console.log('Skipping auto-restore (New project)');
                return false;
            }
            
            try {
                const saved = localStorage.getItem('nes-music-maker-autosave');
                if (saved) {
                    const projectData = JSON.parse(saved);
                    
                    // Restore tracks
                    convertedTracks = projectData.tracks || convertedTracks;
                    
                    // Restore instruments
                    if (projectData.instruments) {
                        instruments = projectData.instruments;
                        renderInstrumentsList();
                    }
                    
                    // Restore settings
                    songLength = projectData.songLength || songLength;
                    currentDrawingInstrument = projectData.currentDrawingInstrument || currentDrawingInstrument;
                    
                    // Restore BPM
                    if (projectData.bpm) {
                        bpm = projectData.bpm;
                        const bpmInput = document.getElementById('bpmInput');
                        if (bpmInput) bpmInput.value = bpm;
                    }
                    
                    // Restore time signature
                    if (projectData.timeSignature) {
                        timeSignature = projectData.timeSignature;
                        const timeSignatureSelect = document.getElementById('timeSignature');
                        if (timeSignatureSelect) timeSignatureSelect.value = timeSignature;
                        updateTimelineGrid();
                    }
                    
                    // Restore quantization
                    if (projectData.quantization) {
                        const noteQuantization = document.getElementById('noteQuantization');
                        if (noteQuantization) noteQuantization.value = projectData.quantization;
                    }
                    
                    // Update song length input
                    const songLengthInput = document.getElementById('songLengthInput');
                    if (songLengthInput) songLengthInput.value = songLength;
                    
                    if (projectData.zoomLevel) {
                        zoomLevel = projectData.zoomLevel;
                        pixelsPerSecond = (zoomLevel / 100) * 50;
                        updateZoomDisplay();
                    }
                    
                    // Visualize all tracks (use setTimeout to ensure DOM is fully settled)
                    setTimeout(() => {
                        // First, ensure all tracks are in collapsed state
                        expandedTrack = null;
                        Object.keys(trackElements).forEach(channel => {
                            const trackEl = trackElements[channel];
                            const trackDiv = trackEl.closest('.track');
                            if (trackDiv) trackDiv.classList.remove('expanded');
                            trackEl.classList.remove('piano-roll-mode');
                            
                            // Force clear the simple content to trigger a full redraw
                            const simpleContent = trackEl.querySelector('.track-simple-content');
                            if (simpleContent) {
                                simpleContent.innerHTML = '';
                            }
                        });
                        
                        // Wait for DOM to update after class removal
                        setTimeout(() => {
                            // Redraw the timeline grid
                            updateTimelineGrid();
                            
                            // Then visualize all tracks with notes
                            Object.keys(convertedTracks).forEach(channel => {
                                if (convertedTracks[channel] && convertedTracks[channel].notes) {
                                    console.log('Auto-restore - visualizing track:', channel, 'notes:', convertedTracks[channel].notes.length);
                                    visualizeTrack(channel, convertedTracks[channel]);
                                }
                            });
                            
                            // Redraw the top timeline notes canvas
                            if (window.renderTimelineNotes) {
                                window.renderTimelineNotes();
                            }
                        }, 50);
                    }, 0);
                    
                    const date = new Date(projectData.timestamp);
                    updateStatus(`‚úì Restored project from ${date.toLocaleString()}`);
                    console.log('Project restored from auto-save');
                    return true;
                }
            } catch (e) {
                console.error('Failed to restore project:', e);
            }
            return false;
        }
        
        function downloadProject() {
            // Prompt user for filename
            const defaultName = `nes-project-${new Date().toISOString().slice(0, 10)}`;
            let filename = prompt('Save project as:', defaultName);
            
            // Cancel if user cancels
            if (filename === null) {
                return;
            }
            
            // Clean up filename
            filename = filename.trim();
            if (!filename) {
                filename = defaultName;
            }
            
            // Remove .json extension if user added it (we'll add it)
            if (filename.endsWith('.json')) {
                filename = filename.slice(0, -5);
            }
            
            const projectData = {
                tracks: convertedTracks,
                instruments: instruments,
                songLength: songLength,
                bpm: bpm,
                timeSignature: timeSignature,
                quantization: document.getElementById('noteQuantization')?.value || 'eighth',
                currentDrawingInstrument: currentDrawingInstrument,
                pixelsPerSecond: pixelsPerSecond,
                zoomLevel: zoomLevel,
                timestamp: Date.now(),
                version: '1.0'
            };
            
            const dataStr = JSON.stringify(projectData, null, 2);
            const blob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${filename}.json`;
            a.click();
            URL.revokeObjectURL(url);
            
            updateStatus(`üíæ Project saved as ${filename}.json`);
        }
        
        function uploadProject() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = (e) => {
                const file = e.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const projectData = JSON.parse(event.target.result);
                        
                        // Restore everything
                        convertedTracks = projectData.tracks || convertedTracks;
                        
                        if (projectData.instruments) {
                            instruments = projectData.instruments;
                            renderInstrumentsList();
                        }
                        
                        songLength = projectData.songLength || songLength;
                        currentDrawingInstrument = projectData.currentDrawingInstrument || currentDrawingInstrument;
                        
                        if (projectData.zoomLevel) {
                            zoomLevel = projectData.zoomLevel;
                            pixelsPerSecond = (zoomLevel / 100) * 50;
                            updateZoomDisplay();
                        }
                        
                        // Update song length input
                        const songLengthInput = document.getElementById('songLengthInput');
                        if (songLengthInput) songLengthInput.value = songLength;
                        if (songLengthDisplay) songLengthDisplay.textContent = `${songLength.toFixed(1)}s`;
                        
                        // Visualize all tracks (use setTimeout to ensure DOM is fully settled)
                        setTimeout(() => {
                            // First, ensure all tracks are in collapsed state
                            expandedTrack = null;
                            Object.keys(trackElements).forEach(channel => {
                                const trackEl = trackElements[channel];
                                const trackDiv = trackEl.closest('.track');
                                if (trackDiv) trackDiv.classList.remove('expanded');
                                trackEl.classList.remove('piano-roll-mode');
                                
                                // Force clear the simple content to trigger a full redraw
                                const simpleContent = trackEl.querySelector('.track-simple-content');
                                if (simpleContent) {
                                    simpleContent.innerHTML = '';
                                }
                            });
                            
                            // Force browser reflow
                            document.body.offsetHeight;
                            
                            // Wait for DOM to update after class removal
                            setTimeout(() => {
                                // Redraw the timeline grid
                                updateTimelineGrid();
                                
                                // Then visualize all tracks with notes
                                Object.keys(convertedTracks).forEach(channel => {
                                    if (convertedTracks[channel] && convertedTracks[channel].notes) {
                                        console.log('Loading project - visualizing track:', channel, 'notes:', convertedTracks[channel].notes.length);
                                        const trackEl = trackElements[channel];
                                        console.log('  trackEl classes:', trackEl.className);
                                        console.log('  piano-roll-mode?', trackEl.classList.contains('piano-roll-mode'));
                                        visualizeTrack(channel, convertedTracks[channel]);
                                        
                                        // Check if notes were actually added
                                        const simpleContent = trackEl.querySelector('.track-simple-content');
                                        const noteBlocks = simpleContent ? simpleContent.querySelectorAll('.note-block') : [];
                                        console.log('  note blocks created:', noteBlocks.length);
                                    }
                                });
                                
                                // Force another reflow
                                document.body.offsetHeight;
                                
                                // Redraw the top timeline notes canvas
                                if (window.renderTimelineNotes) {
                                    window.renderTimelineNotes();
                                }
                            }, 100);
                        }, 0);
                        
                        // Save to localStorage
                        saveProject();
                        
                        updateStatus(`‚úì Loaded project: ${file.name}`);
                    } catch (e) {
                        console.error('Failed to load project:', e);
                        updateStatus('‚ùå Failed to load project file');
                    }
                };
                reader.readAsText(file);
            };
            input.click();
        }
        
        function newProject() {
            if (confirm('Start a new project? Any unsaved changes will be lost.')) {
                // Set flag to prevent auto-restore on next load
                localStorage.setItem('nes-music-maker-skip-restore', 'true');
                
                // Clear auto-save data
                localStorage.removeItem('nes-music-maker-autosave');
                
                // Reload page
                window.location.reload();
            }
        }
        
        // Manual Save/Load/New buttons
        document.getElementById('newProjectBtn').addEventListener('click', newProject);
        document.getElementById('saveProjectBtn').addEventListener('click', downloadProject);
        
        // Auto-save every 30 seconds
        setInterval(saveProject, 30000);
        
        // Also save on any track change
        const originalRenderInlinePianoRoll = renderInlinePianoRoll;
        renderInlinePianoRoll = function(channel) {
            const result = originalRenderInlinePianoRoll(channel);
            saveProject();
            return result;
        };
        
        const originalVisualizeTrack = visualizeTrack;
        visualizeTrack = function(channel, track) {
            const result = originalVisualizeTrack(channel, track);
            saveProject();
            return result;
        };
        
        // Save before page unload
        window.addEventListener('beforeunload', saveProject);
        
        // Try to restore on page load
        const restored = loadProject();
        if (!restored) {
            console.log('No saved project found - starting fresh');
        }
        
        // Set default focused track (after everything is initialized)
        focusTrack('pulse1');
        
    </script>

    </div>
    <!-- Export Metadata Modal -->
    <div id="exportModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.8); z-index: 10000; align-items: center; justify-content: center;">
        <div style="background: var(--bg-dark); border: 2px solid var(--accent-1); border-radius: 8px; padding: 24px; width: 90%; max-width: 500px; box-shadow: 0 8px 32px rgba(0, 255, 159, 0.3);">
            <h2 style="margin: 0 0 20px 0; color: var(--accent-1); font-size: 1.3rem;">Export to FamiTracker</h2>
            
            <div style="margin-bottom: 16px;">
                <label style="display: block; font-size: 0.9rem; color: var(--text-secondary); margin-bottom: 6px;">Song Title</label>
                <input type="text" id="exportTitle" value="Untitled Song" style="width: 100%; padding: 8px; background: var(--bg-mid); color: var(--text-primary); border: 1px solid var(--accent-1); border-radius: 4px; font-size: 0.9rem; box-sizing: border-box;">
            </div>
            
            <div style="margin-bottom: 16px;">
                <label style="display: block; font-size: 0.9rem; color: var(--text-secondary); margin-bottom: 6px;">Author</label>
                <input type="text" id="exportAuthor" value="" style="width: 100%; padding: 8px; background: var(--bg-mid); color: var(--text-primary); border: 1px solid var(--accent-1); border-radius: 4px; font-size: 0.9rem; box-sizing: border-box;">
            </div>
            
            <div style="margin-bottom: 16px;">
                <label style="display: block; font-size: 0.9rem; color: var(--text-secondary); margin-bottom: 6px;">Copyright</label>
                <input type="text" id="exportCopyright" value="" style="width: 100%; padding: 8px; background: var(--bg-mid); color: var(--text-primary); border: 1px solid var(--accent-1); border-radius: 4px; font-size: 0.9rem; box-sizing: border-box;">
            </div>
            
            <div style="margin-bottom: 20px;">
                <label style="display: block; font-size: 0.9rem; color: var(--text-secondary); margin-bottom: 6px;">Comment (optional)</label>
                <textarea id="exportComment" rows="3" style="width: 100%; padding: 8px; background: var(--bg-mid); color: var(--text-primary); border: 1px solid var(--accent-1); border-radius: 4px; font-size: 0.9rem; resize: vertical; box-sizing: border-box;"></textarea>
            </div>
            
            <div style="display: flex; gap: 12px; justify-content: flex-end;">
                <button id="exportCancelBtn" style="padding: 10px 20px; background: var(--bg-mid); border: 1px solid var(--accent-1); border-radius: 4px; cursor: pointer; color: var(--text-primary); font-size: 0.9rem;">
                    Cancel
                </button>
                <button id="exportConfirmBtn" style="padding: 10px 20px; background: linear-gradient(135deg, var(--accent-4) 0%, #d69e00 100%); border: none; border-radius: 4px; cursor: pointer; color: white; font-size: 0.9rem;">
                    Export
                </button>
            </div>
        </div>
    </div>

    <!-- Footer -->
    <footer style="text-align: center; padding: 30px 20px; margin-top: 40px; border-top: 2px solid var(--accent-1); background: var(--bg-dark); color: var(--text-secondary); font-size: 0.9rem; line-height: 1.8;">
        <div style="margin-bottom: 10px;">
            Created by <strong style="color: var(--accent-1);">Matt Milstead</strong> ‚Ä¢ Copyright ¬© 2026
        </div>
        <div style="font-size: 0.85rem;">
            If you enjoyed this, feel free to send me a cup of coffee ‚òï
        </div>
        <div style="margin-top: 10px; font-family: monospace; font-size: 0.75rem; color: var(--text-primary); background: var(--bg-mid); padding: 8px 12px; border-radius: 4px; display: inline-block; word-break: break-all; max-width: 600px;">
            21ic14aRQGKniHaSgihc7oatboaQpAw6q5qNh6TEXeqe
        </div>
    </footer>

</body>
</html>
